/*
Package otgyang is a generated package which contains definitions
of structs which represent a YANG schema. The generated schema can be
compressed by a series of transformations (compression was true
in this case).

This package was generated by /usr/local/google/home/robjs/go/pkg/mod/github.com/openconfig/ygot@v0.29.9/genutil/names.go
using the following YANG input files:
  - models-yang/models/interface/open-traffic-generator-port.yang
  - models-yang/models/flow/open-traffic-generator-flow.yang
  - models-yang/models/discovery/open-traffic-generator-discovery-interfaces.yang
  - models-yang/models/discovery/open-traffic-generator-discovery.yang

Imported modules were sourced from:
  - models-yang/...
*/
package otgyang

import (
	"encoding/json"
	"fmt"
	"reflect"

	"github.com/openconfig/goyang/pkg/yang"
	"github.com/openconfig/ygot/ygot"
	"github.com/openconfig/ygot/ytypes"
)

// Binary is a type that is used for fields that have a YANG type of
// binary. It is used such that binary fields can be distinguished from
// leaf-lists of uint8s (which are mapped to []uint8, equivalent to
// []byte in reflection).
type Binary []byte

// YANGEmpty is a type that is used for fields that have a YANG type of
// empty. It is used such that empty fields can be distinguished from boolean fields
// in the generated code.
type YANGEmpty bool

// UnionInt8 is an int8 type assignable to unions of which it is a subtype.
type UnionInt8 int8

// UnionInt16 is an int16 type assignable to unions of which it is a subtype.
type UnionInt16 int16

// UnionInt32 is an int32 type assignable to unions of which it is a subtype.
type UnionInt32 int32

// UnionInt64 is an int64 type assignable to unions of which it is a subtype.
type UnionInt64 int64

// UnionUint8 is a uint8 type assignable to unions of which it is a subtype.
type UnionUint8 uint8

// UnionUint16 is a uint16 type assignable to unions of which it is a subtype.
type UnionUint16 uint16

// UnionUint32 is a uint32 type assignable to unions of which it is a subtype.
type UnionUint32 uint32

// UnionUint64 is a uint64 type assignable to unions of which it is a subtype.
type UnionUint64 uint64

// UnionFloat64 is a float64 type assignable to unions of which it is a subtype.
type UnionFloat64 float64

// UnionString is a string type assignable to unions of which it is a subtype.
type UnionString string

// UnionBool is a bool type assignable to unions of which it is a subtype.
type UnionBool bool

// UnionUnsupported is an interface{} wrapper type for unsupported types. It is
// assignable to unions of which it is a subtype.
type UnionUnsupported struct {
	Value interface{}
}

var (
	SchemaTree map[string]*yang.Entry
	ΛEnumTypes map[string][]reflect.Type
)

func init() {
	var err error
	initΛEnumTypes()
	if SchemaTree, err = UnzipSchema(); err != nil {
		panic("schema error: " + err.Error())
	}
}

// Schema returns the details of the generated schema.
func Schema() (*ytypes.Schema, error) {
	uzp, err := UnzipSchema()
	if err != nil {
		return nil, fmt.Errorf("cannot unzip schema, %v", err)
	}

	return &ytypes.Schema{
		Root:       &Device{},
		SchemaTree: uzp,
		Unmarshal:  Unmarshal,
	}, nil
}

// UnzipSchema unzips the zipped schema and returns a map of yang.Entry nodes,
// keyed by the name of the struct that the yang.Entry describes the schema for.
func UnzipSchema() (map[string]*yang.Entry, error) {
	var schemaTree map[string]*yang.Entry
	var err error
	if schemaTree, err = ygot.GzipToSchema(ySchema); err != nil {
		return nil, fmt.Errorf("could not unzip the schema; %v", err)
	}
	return schemaTree, nil
}

// Unmarshal unmarshals data, which must be RFC7951 JSON format, into
// destStruct, which must be non-nil and the correct GoStruct type. It returns
// an error if the destStruct is not found in the schema or the data cannot be
// unmarshaled. The supplied options (opts) are used to control the behaviour
// of the unmarshal function - for example, determining whether errors are
// thrown for unknown fields in the input JSON.
func Unmarshal(data []byte, destStruct ygot.GoStruct, opts ...ytypes.UnmarshalOpt) error {
	tn := reflect.TypeOf(destStruct).Elem().Name()
	schema, ok := SchemaTree[tn]
	if !ok {
		return fmt.Errorf("could not find schema for type %s", tn)
	}
	var jsonTree interface{}
	if err := json.Unmarshal([]byte(data), &jsonTree); err != nil {
		return err
	}
	return ytypes.Unmarshal(schema, destStruct, jsonTree, opts...)
}

// Device represents the /device YANG schema element.
type Device struct {
	ΛMetadata  []ygot.Annotation     `path:"@" ygotAnnotation:"true"`
	Flow       map[string]*Flow      `path:"flows/flow" module:"open-traffic-generator-flow/open-traffic-generator-flow"`
	ΛFlow      []ygot.Annotation     `path:"flows/@flow" ygotAnnotation:"true"`
	Interface  map[string]*Interface `path:"interfaces/interface" module:"open-traffic-generator-discovery/open-traffic-generator-discovery"`
	ΛInterface []ygot.Annotation     `path:"interfaces/@interface" ygotAnnotation:"true"`
	Port       map[string]*Port      `path:"ports/port" module:"open-traffic-generator-port/open-traffic-generator-port"`
	ΛPort      []ygot.Annotation     `path:"ports/@port" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Device implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Device) IsYANGGoStruct() {}

// NewFlow creates a new entry in the Flow list of the
// Device struct. The keys of the list are populated from the input
// arguments.
func (t *Device) NewFlow(Name string) (*Flow, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Flow == nil {
		t.Flow = make(map[string]*Flow)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Flow[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Flow", key)
	}

	t.Flow[key] = &Flow{
		Name: &Name,
	}

	return t.Flow[key], nil
}

// RenameFlow renames an entry in the list Flow within
// the Device struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Device) RenameFlow(oldK, newK string) error {
	if _, ok := t.Flow[newK]; ok {
		return fmt.Errorf("key %v already exists in Flow", newK)
	}

	e, ok := t.Flow[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Flow", oldK)
	}
	e.Name = &newK

	t.Flow[newK] = e
	delete(t.Flow, oldK)
	return nil
}

// GetOrCreateFlow retrieves the value with the specified keys from
// the receiver Device. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Device) GetOrCreateFlow(Name string) *Flow {

	key := Name

	if v, ok := t.Flow[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewFlow(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateFlow got unexpected error: %v", err))
	}
	return v
}

// GetFlow retrieves the value with the specified key from
// the Flow map field of Device. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Device) GetFlow(Name string) *Flow {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Flow[key]; ok {
		return lm
	}
	return nil
}

// AppendFlow appends the supplied Flow struct to the
// list Flow of Device. If the key value(s) specified in
// the supplied Flow already exist in the list, an error is
// returned.
func (t *Device) AppendFlow(v *Flow) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Flow == nil {
		t.Flow = make(map[string]*Flow)
	}

	if _, ok := t.Flow[key]; ok {
		return fmt.Errorf("duplicate key for list Flow %v", key)
	}

	t.Flow[key] = v
	return nil
}

// NewInterface creates a new entry in the Interface list of the
// Device struct. The keys of the list are populated from the input
// arguments.
func (t *Device) NewInterface(Name string) (*Interface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*Interface)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &Interface{
		Name: &Name,
	}

	return t.Interface[key], nil
}

// RenameInterface renames an entry in the list Interface within
// the Device struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Device) RenameInterface(oldK, newK string) error {
	if _, ok := t.Interface[newK]; ok {
		return fmt.Errorf("key %v already exists in Interface", newK)
	}

	e, ok := t.Interface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Interface", oldK)
	}
	e.Name = &newK

	t.Interface[newK] = e
	delete(t.Interface, oldK)
	return nil
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver Device. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Device) GetOrCreateInterface(Name string) *Interface {

	key := Name

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of Device. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Device) GetInterface(Name string) *Interface {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// AppendInterface appends the supplied Interface struct to the
// list Interface of Device. If the key value(s) specified in
// the supplied Interface already exist in the list, an error is
// returned.
func (t *Device) AppendInterface(v *Interface) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// NewPort creates a new entry in the Port list of the
// Device struct. The keys of the list are populated from the input
// arguments.
func (t *Device) NewPort(Name string) (*Port, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Port == nil {
		t.Port = make(map[string]*Port)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Port[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Port", key)
	}

	t.Port[key] = &Port{
		Name: &Name,
	}

	return t.Port[key], nil
}

// RenamePort renames an entry in the list Port within
// the Device struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Device) RenamePort(oldK, newK string) error {
	if _, ok := t.Port[newK]; ok {
		return fmt.Errorf("key %v already exists in Port", newK)
	}

	e, ok := t.Port[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Port", oldK)
	}
	e.Name = &newK

	t.Port[newK] = e
	delete(t.Port, oldK)
	return nil
}

// GetOrCreatePort retrieves the value with the specified keys from
// the receiver Device. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Device) GetOrCreatePort(Name string) *Port {

	key := Name

	if v, ok := t.Port[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPort(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePort got unexpected error: %v", err))
	}
	return v
}

// GetPort retrieves the value with the specified key from
// the Port map field of Device. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Device) GetPort(Name string) *Port {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Port[key]; ok {
		return lm
	}
	return nil
}

// AppendPort appends the supplied Port struct to the
// list Port of Device. If the key value(s) specified in
// the supplied Port already exist in the list, an error is
// returned.
func (t *Device) AppendPort(v *Port) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Port == nil {
		t.Port = make(map[string]*Port)
	}

	if _, ok := t.Port[key]; ok {
		return fmt.Errorf("duplicate key for list Port %v", key)
	}

	t.Port[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the Device
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Device) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Flow {
		e.PopulateDefaults()
	}
	for _, e := range t.Interface {
		e.PopulateDefaults()
	}
	for _, e := range t.Port {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Device) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Device"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Device) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Device) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Device.
func (*Device) ΛBelongingModule() string {
	return ""
}

// Flow represents the /open-traffic-generator-flow/flows/flow YANG schema element.
type Flow struct {
	ΛMetadata       []ygot.Annotation             `path:"@" ygotAnnotation:"true"`
	AverageLatency  *uint64                       `path:"state/average-latency" module:"open-traffic-generator-flow/open-traffic-generator-flow"`
	ΛAverageLatency []ygot.Annotation             `path:"state/@average-latency" ygotAnnotation:"true"`
	Counters        *Flow_Counters                `path:"state/counters" module:"open-traffic-generator-flow/open-traffic-generator-flow"`
	ΛCounters       []ygot.Annotation             `path:"state/@counters" ygotAnnotation:"true"`
	InFrameRate     Binary                        `path:"state/in-frame-rate" module:"open-traffic-generator-flow/open-traffic-generator-flow"`
	ΛInFrameRate    []ygot.Annotation             `path:"state/@in-frame-rate" ygotAnnotation:"true"`
	InRate          Binary                        `path:"state/in-rate" module:"open-traffic-generator-flow/open-traffic-generator-flow"`
	ΛInRate         []ygot.Annotation             `path:"state/@in-rate" ygotAnnotation:"true"`
	LossPct         Binary                        `path:"state/loss-pct" module:"open-traffic-generator-flow/open-traffic-generator-flow"`
	ΛLossPct        []ygot.Annotation             `path:"state/@loss-pct" ygotAnnotation:"true"`
	MaximumLatency  *uint64                       `path:"state/maximum-latency" module:"open-traffic-generator-flow/open-traffic-generator-flow"`
	ΛMaximumLatency []ygot.Annotation             `path:"state/@maximum-latency" ygotAnnotation:"true"`
	MinimumLatency  *uint64                       `path:"state/minimum-latency" module:"open-traffic-generator-flow/open-traffic-generator-flow"`
	ΛMinimumLatency []ygot.Annotation             `path:"state/@minimum-latency" ygotAnnotation:"true"`
	Name            *string                       `path:"state/name|name" module:"open-traffic-generator-flow/open-traffic-generator-flow|open-traffic-generator-flow"`
	ΛName           []ygot.Annotation             `path:"state/@name|@name" ygotAnnotation:"true"`
	OutFrameRate    Binary                        `path:"state/out-frame-rate" module:"open-traffic-generator-flow/open-traffic-generator-flow"`
	ΛOutFrameRate   []ygot.Annotation             `path:"state/@out-frame-rate" ygotAnnotation:"true"`
	OutRate         Binary                        `path:"state/out-rate" module:"open-traffic-generator-flow/open-traffic-generator-flow"`
	ΛOutRate        []ygot.Annotation             `path:"state/@out-rate" ygotAnnotation:"true"`
	TaggedMetric    map[string]*Flow_TaggedMetric `path:"tagged-metrics/tagged-metric" module:"open-traffic-generator-flow/open-traffic-generator-flow"`
	ΛTaggedMetric   []ygot.Annotation             `path:"tagged-metrics/@tagged-metric" ygotAnnotation:"true"`
	Transmit        *bool                         `path:"state/transmit" module:"open-traffic-generator-flow/open-traffic-generator-flow"`
	ΛTransmit       []ygot.Annotation             `path:"state/@transmit" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Flow implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Flow) IsYANGGoStruct() {}

// NewTaggedMetric creates a new entry in the TaggedMetric list of the
// Flow struct. The keys of the list are populated from the input
// arguments.
func (t *Flow) NewTaggedMetric(NameValuePairs string) (*Flow_TaggedMetric, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.TaggedMetric == nil {
		t.TaggedMetric = make(map[string]*Flow_TaggedMetric)
	}

	key := NameValuePairs

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.TaggedMetric[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list TaggedMetric", key)
	}

	t.TaggedMetric[key] = &Flow_TaggedMetric{
		NameValuePairs: &NameValuePairs,
	}

	return t.TaggedMetric[key], nil
}

// RenameTaggedMetric renames an entry in the list TaggedMetric within
// the Flow struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Flow) RenameTaggedMetric(oldK, newK string) error {
	if _, ok := t.TaggedMetric[newK]; ok {
		return fmt.Errorf("key %v already exists in TaggedMetric", newK)
	}

	e, ok := t.TaggedMetric[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in TaggedMetric", oldK)
	}
	e.NameValuePairs = &newK

	t.TaggedMetric[newK] = e
	delete(t.TaggedMetric, oldK)
	return nil
}

// GetOrCreateTaggedMetric retrieves the value with the specified keys from
// the receiver Flow. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Flow) GetOrCreateTaggedMetric(NameValuePairs string) *Flow_TaggedMetric {

	key := NameValuePairs

	if v, ok := t.TaggedMetric[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewTaggedMetric(NameValuePairs)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateTaggedMetric got unexpected error: %v", err))
	}
	return v
}

// GetTaggedMetric retrieves the value with the specified key from
// the TaggedMetric map field of Flow. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Flow) GetTaggedMetric(NameValuePairs string) *Flow_TaggedMetric {

	if t == nil {
		return nil
	}

	key := NameValuePairs

	if lm, ok := t.TaggedMetric[key]; ok {
		return lm
	}
	return nil
}

// AppendTaggedMetric appends the supplied Flow_TaggedMetric struct to the
// list TaggedMetric of Flow. If the key value(s) specified in
// the supplied Flow_TaggedMetric already exist in the list, an error is
// returned.
func (t *Flow) AppendTaggedMetric(v *Flow_TaggedMetric) error {
	if v.NameValuePairs == nil {
		return fmt.Errorf("invalid nil key received for NameValuePairs")
	}

	key := *v.NameValuePairs

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.TaggedMetric == nil {
		t.TaggedMetric = make(map[string]*Flow_TaggedMetric)
	}

	if _, ok := t.TaggedMetric[key]; ok {
		return fmt.Errorf("duplicate key for list TaggedMetric %v", key)
	}

	t.TaggedMetric[key] = v
	return nil
}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *Flow) GetOrCreateCounters() *Flow_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &Flow_Counters{}
	return t.Counters
}

// GetCounters returns the value of the Counters struct pointer
// from Flow. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Flow) GetCounters() *Flow_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetAverageLatency retrieves the value of the leaf AverageLatency from the Flow
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AverageLatency is set, it can
// safely use t.GetAverageLatency() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AverageLatency == nil' before retrieving the leaf's value.
func (t *Flow) GetAverageLatency() uint64 {
	if t == nil || t.AverageLatency == nil {
		return 0
	}
	return *t.AverageLatency
}

// GetInFrameRate retrieves the value of the leaf InFrameRate from the Flow
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InFrameRate is set, it can
// safely use t.GetInFrameRate() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InFrameRate == nil' before retrieving the leaf's value.
func (t *Flow) GetInFrameRate() Binary {
	if t == nil || t.InFrameRate == nil {
		return nil
	}
	return t.InFrameRate
}

// GetInRate retrieves the value of the leaf InRate from the Flow
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InRate is set, it can
// safely use t.GetInRate() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InRate == nil' before retrieving the leaf's value.
func (t *Flow) GetInRate() Binary {
	if t == nil || t.InRate == nil {
		return nil
	}
	return t.InRate
}

// GetLossPct retrieves the value of the leaf LossPct from the Flow
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LossPct is set, it can
// safely use t.GetLossPct() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LossPct == nil' before retrieving the leaf's value.
func (t *Flow) GetLossPct() Binary {
	if t == nil || t.LossPct == nil {
		return nil
	}
	return t.LossPct
}

// GetMaximumLatency retrieves the value of the leaf MaximumLatency from the Flow
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MaximumLatency is set, it can
// safely use t.GetMaximumLatency() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MaximumLatency == nil' before retrieving the leaf's value.
func (t *Flow) GetMaximumLatency() uint64 {
	if t == nil || t.MaximumLatency == nil {
		return 0
	}
	return *t.MaximumLatency
}

// GetMinimumLatency retrieves the value of the leaf MinimumLatency from the Flow
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MinimumLatency is set, it can
// safely use t.GetMinimumLatency() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MinimumLatency == nil' before retrieving the leaf's value.
func (t *Flow) GetMinimumLatency() uint64 {
	if t == nil || t.MinimumLatency == nil {
		return 0
	}
	return *t.MinimumLatency
}

// GetName retrieves the value of the leaf Name from the Flow
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *Flow) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetOutFrameRate retrieves the value of the leaf OutFrameRate from the Flow
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutFrameRate is set, it can
// safely use t.GetOutFrameRate() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutFrameRate == nil' before retrieving the leaf's value.
func (t *Flow) GetOutFrameRate() Binary {
	if t == nil || t.OutFrameRate == nil {
		return nil
	}
	return t.OutFrameRate
}

// GetOutRate retrieves the value of the leaf OutRate from the Flow
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutRate is set, it can
// safely use t.GetOutRate() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutRate == nil' before retrieving the leaf's value.
func (t *Flow) GetOutRate() Binary {
	if t == nil || t.OutRate == nil {
		return nil
	}
	return t.OutRate
}

// GetTransmit retrieves the value of the leaf Transmit from the Flow
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Transmit is set, it can
// safely use t.GetTransmit() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Transmit == nil' before retrieving the leaf's value.
func (t *Flow) GetTransmit() bool {
	if t == nil || t.Transmit == nil {
		return false
	}
	return *t.Transmit
}

// PopulateDefaults recursively populates unset leaf fields in the Flow
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Flow) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Counters.PopulateDefaults()
	for _, e := range t.TaggedMetric {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the Flow struct, which is a YANG list entry.
func (t *Flow) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Flow) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Flow"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Flow) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Flow) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Flow.
func (*Flow) ΛBelongingModule() string {
	return "open-traffic-generator-flow"
}

// Flow_Counters represents the /open-traffic-generator-flow/flows/flow/state/counters YANG schema element.
type Flow_Counters struct {
	ΛMetadata  []ygot.Annotation `path:"@" ygotAnnotation:"true"`
	InOctets   *uint64           `path:"in-octets" module:"open-traffic-generator-flow"`
	ΛInOctets  []ygot.Annotation `path:"@in-octets" ygotAnnotation:"true"`
	InPkts     *uint64           `path:"in-pkts" module:"open-traffic-generator-flow"`
	ΛInPkts    []ygot.Annotation `path:"@in-pkts" ygotAnnotation:"true"`
	OutOctets  *uint64           `path:"out-octets" module:"open-traffic-generator-flow"`
	ΛOutOctets []ygot.Annotation `path:"@out-octets" ygotAnnotation:"true"`
	OutPkts    *uint64           `path:"out-pkts" module:"open-traffic-generator-flow"`
	ΛOutPkts   []ygot.Annotation `path:"@out-pkts" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Flow_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Flow_Counters) IsYANGGoStruct() {}

// GetInOctets retrieves the value of the leaf InOctets from the Flow_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InOctets is set, it can
// safely use t.GetInOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InOctets == nil' before retrieving the leaf's value.
func (t *Flow_Counters) GetInOctets() uint64 {
	if t == nil || t.InOctets == nil {
		return 0
	}
	return *t.InOctets
}

// GetInPkts retrieves the value of the leaf InPkts from the Flow_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InPkts is set, it can
// safely use t.GetInPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InPkts == nil' before retrieving the leaf's value.
func (t *Flow_Counters) GetInPkts() uint64 {
	if t == nil || t.InPkts == nil {
		return 0
	}
	return *t.InPkts
}

// GetOutOctets retrieves the value of the leaf OutOctets from the Flow_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutOctets is set, it can
// safely use t.GetOutOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutOctets == nil' before retrieving the leaf's value.
func (t *Flow_Counters) GetOutOctets() uint64 {
	if t == nil || t.OutOctets == nil {
		return 0
	}
	return *t.OutOctets
}

// GetOutPkts retrieves the value of the leaf OutPkts from the Flow_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutPkts is set, it can
// safely use t.GetOutPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutPkts == nil' before retrieving the leaf's value.
func (t *Flow_Counters) GetOutPkts() uint64 {
	if t == nil || t.OutPkts == nil {
		return 0
	}
	return *t.OutPkts
}

// PopulateDefaults recursively populates unset leaf fields in the Flow_Counters
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Flow_Counters) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Flow_Counters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Flow_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Flow_Counters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Flow_Counters) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Flow_Counters.
func (*Flow_Counters) ΛBelongingModule() string {
	return "open-traffic-generator-flow"
}

// Flow_TaggedMetric represents the /open-traffic-generator-flow/flows/flow/tagged-metrics/tagged-metric YANG schema element.
type Flow_TaggedMetric struct {
	ΛMetadata       []ygot.Annotation           `path:"@" ygotAnnotation:"true"`
	Counters        *Flow_TaggedMetric_Counters `path:"state/counters" module:"open-traffic-generator-flow/open-traffic-generator-flow"`
	ΛCounters       []ygot.Annotation           `path:"state/@counters" ygotAnnotation:"true"`
	NameValuePairs  *string                     `path:"state/name-value-pairs|name-value-pairs" module:"open-traffic-generator-flow/open-traffic-generator-flow|open-traffic-generator-flow"`
	ΛNameValuePairs []ygot.Annotation           `path:"state/@name-value-pairs|@name-value-pairs" ygotAnnotation:"true"`
	Tags            []*Flow_TaggedMetric_Tags   `path:"state/tags" module:"open-traffic-generator-flow/open-traffic-generator-flow"`
	ΛTags           []ygot.Annotation           `path:"state/@tags" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Flow_TaggedMetric implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Flow_TaggedMetric) IsYANGGoStruct() {}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *Flow_TaggedMetric) GetOrCreateCounters() *Flow_TaggedMetric_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &Flow_TaggedMetric_Counters{}
	return t.Counters
}

// GetCounters returns the value of the Counters struct pointer
// from Flow_TaggedMetric. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Flow_TaggedMetric) GetCounters() *Flow_TaggedMetric_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetNameValuePairs retrieves the value of the leaf NameValuePairs from the Flow_TaggedMetric
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NameValuePairs is set, it can
// safely use t.GetNameValuePairs() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NameValuePairs == nil' before retrieving the leaf's value.
func (t *Flow_TaggedMetric) GetNameValuePairs() string {
	if t == nil || t.NameValuePairs == nil {
		return ""
	}
	return *t.NameValuePairs
}

// PopulateDefaults recursively populates unset leaf fields in the Flow_TaggedMetric
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Flow_TaggedMetric) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Counters.PopulateDefaults()
	for _, e := range t.Tags {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the Flow_TaggedMetric struct, which is a YANG list entry.
func (t *Flow_TaggedMetric) ΛListKeyMap() (map[string]interface{}, error) {
	if t.NameValuePairs == nil {
		return nil, fmt.Errorf("nil value for key NameValuePairs")
	}

	return map[string]interface{}{
		"name-value-pairs": *t.NameValuePairs,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Flow_TaggedMetric) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Flow_TaggedMetric"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Flow_TaggedMetric) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Flow_TaggedMetric) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Flow_TaggedMetric.
func (*Flow_TaggedMetric) ΛBelongingModule() string {
	return "open-traffic-generator-flow"
}

// Flow_TaggedMetric_Counters represents the /open-traffic-generator-flow/flows/flow/tagged-metrics/tagged-metric/state/counters YANG schema element.
type Flow_TaggedMetric_Counters struct {
	ΛMetadata  []ygot.Annotation `path:"@" ygotAnnotation:"true"`
	InOctets   *uint64           `path:"in-octets" module:"open-traffic-generator-flow"`
	ΛInOctets  []ygot.Annotation `path:"@in-octets" ygotAnnotation:"true"`
	InPkts     *uint64           `path:"in-pkts" module:"open-traffic-generator-flow"`
	ΛInPkts    []ygot.Annotation `path:"@in-pkts" ygotAnnotation:"true"`
	OutOctets  *uint64           `path:"out-octets" module:"open-traffic-generator-flow"`
	ΛOutOctets []ygot.Annotation `path:"@out-octets" ygotAnnotation:"true"`
	OutPkts    *uint64           `path:"out-pkts" module:"open-traffic-generator-flow"`
	ΛOutPkts   []ygot.Annotation `path:"@out-pkts" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Flow_TaggedMetric_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Flow_TaggedMetric_Counters) IsYANGGoStruct() {}

// GetInOctets retrieves the value of the leaf InOctets from the Flow_TaggedMetric_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InOctets is set, it can
// safely use t.GetInOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InOctets == nil' before retrieving the leaf's value.
func (t *Flow_TaggedMetric_Counters) GetInOctets() uint64 {
	if t == nil || t.InOctets == nil {
		return 0
	}
	return *t.InOctets
}

// GetInPkts retrieves the value of the leaf InPkts from the Flow_TaggedMetric_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InPkts is set, it can
// safely use t.GetInPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InPkts == nil' before retrieving the leaf's value.
func (t *Flow_TaggedMetric_Counters) GetInPkts() uint64 {
	if t == nil || t.InPkts == nil {
		return 0
	}
	return *t.InPkts
}

// GetOutOctets retrieves the value of the leaf OutOctets from the Flow_TaggedMetric_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutOctets is set, it can
// safely use t.GetOutOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutOctets == nil' before retrieving the leaf's value.
func (t *Flow_TaggedMetric_Counters) GetOutOctets() uint64 {
	if t == nil || t.OutOctets == nil {
		return 0
	}
	return *t.OutOctets
}

// GetOutPkts retrieves the value of the leaf OutPkts from the Flow_TaggedMetric_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutPkts is set, it can
// safely use t.GetOutPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutPkts == nil' before retrieving the leaf's value.
func (t *Flow_TaggedMetric_Counters) GetOutPkts() uint64 {
	if t == nil || t.OutPkts == nil {
		return 0
	}
	return *t.OutPkts
}

// PopulateDefaults recursively populates unset leaf fields in the Flow_TaggedMetric_Counters
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Flow_TaggedMetric_Counters) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Flow_TaggedMetric_Counters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Flow_TaggedMetric_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Flow_TaggedMetric_Counters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Flow_TaggedMetric_Counters) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Flow_TaggedMetric_Counters.
func (*Flow_TaggedMetric_Counters) ΛBelongingModule() string {
	return "open-traffic-generator-flow"
}

// Flow_TaggedMetric_Tags represents the /open-traffic-generator-flow/flows/flow/tagged-metrics/tagged-metric/state/tags YANG schema element.
type Flow_TaggedMetric_Tags struct {
	ΛMetadata []ygot.Annotation                `path:"@" ygotAnnotation:"true"`
	TagName   *string                          `path:"tag-name" module:"open-traffic-generator-flow"`
	ΛTagName  []ygot.Annotation                `path:"@tag-name" ygotAnnotation:"true"`
	TagValue  *Flow_TaggedMetric_Tags_TagValue `path:"tag-value" module:"open-traffic-generator-flow"`
	ΛTagValue []ygot.Annotation                `path:"@tag-value" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Flow_TaggedMetric_Tags implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Flow_TaggedMetric_Tags) IsYANGGoStruct() {}

// GetOrCreateTagValue retrieves the value of the TagValue field
// or returns the existing field if it already exists.
func (t *Flow_TaggedMetric_Tags) GetOrCreateTagValue() *Flow_TaggedMetric_Tags_TagValue {
	if t.TagValue != nil {
		return t.TagValue
	}
	t.TagValue = &Flow_TaggedMetric_Tags_TagValue{}
	return t.TagValue
}

// GetTagValue returns the value of the TagValue struct pointer
// from Flow_TaggedMetric_Tags. If the receiver or the field TagValue is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Flow_TaggedMetric_Tags) GetTagValue() *Flow_TaggedMetric_Tags_TagValue {
	if t != nil && t.TagValue != nil {
		return t.TagValue
	}
	return nil
}

// GetTagName retrieves the value of the leaf TagName from the Flow_TaggedMetric_Tags
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TagName is set, it can
// safely use t.GetTagName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TagName == nil' before retrieving the leaf's value.
func (t *Flow_TaggedMetric_Tags) GetTagName() string {
	if t == nil || t.TagName == nil {
		return ""
	}
	return *t.TagName
}

// PopulateDefaults recursively populates unset leaf fields in the Flow_TaggedMetric_Tags
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Flow_TaggedMetric_Tags) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.TagValue.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Flow_TaggedMetric_Tags) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Flow_TaggedMetric_Tags"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Flow_TaggedMetric_Tags) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Flow_TaggedMetric_Tags) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Flow_TaggedMetric_Tags.
func (*Flow_TaggedMetric_Tags) ΛBelongingModule() string {
	return "open-traffic-generator-flow"
}

// Flow_TaggedMetric_Tags_TagValue represents the /open-traffic-generator-flow/flows/flow/tagged-metrics/tagged-metric/state/tags/tag-value YANG schema element.
type Flow_TaggedMetric_Tags_TagValue struct {
	ΛMetadata         []ygot.Annotation `path:"@" ygotAnnotation:"true"`
	ValueAsBool       *bool             `path:"value-as-bool" module:"open-traffic-generator-flow"`
	ΛValueAsBool      []ygot.Annotation `path:"@value-as-bool" ygotAnnotation:"true"`
	ValueAsCounter64  *uint64           `path:"value-as-counter64" module:"open-traffic-generator-flow"`
	ΛValueAsCounter64 []ygot.Annotation `path:"@value-as-counter64" ygotAnnotation:"true"`
	ValueAsFloat32    Binary            `path:"value-as-float32" module:"open-traffic-generator-flow"`
	ΛValueAsFloat32   []ygot.Annotation `path:"@value-as-float32" ygotAnnotation:"true"`
	ValueAsHex        *string           `path:"value-as-hex" module:"open-traffic-generator-flow"`
	ΛValueAsHex       []ygot.Annotation `path:"@value-as-hex" ygotAnnotation:"true"`
	ValueAsIpv4       *string           `path:"value-as-ipv4" module:"open-traffic-generator-flow"`
	ΛValueAsIpv4      []ygot.Annotation `path:"@value-as-ipv4" ygotAnnotation:"true"`
	ValueAsIpv6       *string           `path:"value-as-ipv6" module:"open-traffic-generator-flow"`
	ΛValueAsIpv6      []ygot.Annotation `path:"@value-as-ipv6" ygotAnnotation:"true"`
	ValueAsMac        *string           `path:"value-as-mac" module:"open-traffic-generator-flow"`
	ΛValueAsMac       []ygot.Annotation `path:"@value-as-mac" ygotAnnotation:"true"`
	ValueAsString     *string           `path:"value-as-string" module:"open-traffic-generator-flow"`
	ΛValueAsString    []ygot.Annotation `path:"@value-as-string" ygotAnnotation:"true"`
	ValueType         E_Tags_ValueType  `path:"value-type" module:"open-traffic-generator-flow"`
	ΛValueType        []ygot.Annotation `path:"@value-type" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Flow_TaggedMetric_Tags_TagValue implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Flow_TaggedMetric_Tags_TagValue) IsYANGGoStruct() {}

// GetValueAsBool retrieves the value of the leaf ValueAsBool from the Flow_TaggedMetric_Tags_TagValue
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ValueAsBool is set, it can
// safely use t.GetValueAsBool() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ValueAsBool == nil' before retrieving the leaf's value.
func (t *Flow_TaggedMetric_Tags_TagValue) GetValueAsBool() bool {
	if t == nil || t.ValueAsBool == nil {
		return false
	}
	return *t.ValueAsBool
}

// GetValueAsCounter64 retrieves the value of the leaf ValueAsCounter64 from the Flow_TaggedMetric_Tags_TagValue
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ValueAsCounter64 is set, it can
// safely use t.GetValueAsCounter64() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ValueAsCounter64 == nil' before retrieving the leaf's value.
func (t *Flow_TaggedMetric_Tags_TagValue) GetValueAsCounter64() uint64 {
	if t == nil || t.ValueAsCounter64 == nil {
		return 0
	}
	return *t.ValueAsCounter64
}

// GetValueAsFloat32 retrieves the value of the leaf ValueAsFloat32 from the Flow_TaggedMetric_Tags_TagValue
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ValueAsFloat32 is set, it can
// safely use t.GetValueAsFloat32() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ValueAsFloat32 == nil' before retrieving the leaf's value.
func (t *Flow_TaggedMetric_Tags_TagValue) GetValueAsFloat32() Binary {
	if t == nil || t.ValueAsFloat32 == nil {
		return nil
	}
	return t.ValueAsFloat32
}

// GetValueAsHex retrieves the value of the leaf ValueAsHex from the Flow_TaggedMetric_Tags_TagValue
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ValueAsHex is set, it can
// safely use t.GetValueAsHex() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ValueAsHex == nil' before retrieving the leaf's value.
func (t *Flow_TaggedMetric_Tags_TagValue) GetValueAsHex() string {
	if t == nil || t.ValueAsHex == nil {
		return ""
	}
	return *t.ValueAsHex
}

// GetValueAsIpv4 retrieves the value of the leaf ValueAsIpv4 from the Flow_TaggedMetric_Tags_TagValue
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ValueAsIpv4 is set, it can
// safely use t.GetValueAsIpv4() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ValueAsIpv4 == nil' before retrieving the leaf's value.
func (t *Flow_TaggedMetric_Tags_TagValue) GetValueAsIpv4() string {
	if t == nil || t.ValueAsIpv4 == nil {
		return ""
	}
	return *t.ValueAsIpv4
}

// GetValueAsIpv6 retrieves the value of the leaf ValueAsIpv6 from the Flow_TaggedMetric_Tags_TagValue
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ValueAsIpv6 is set, it can
// safely use t.GetValueAsIpv6() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ValueAsIpv6 == nil' before retrieving the leaf's value.
func (t *Flow_TaggedMetric_Tags_TagValue) GetValueAsIpv6() string {
	if t == nil || t.ValueAsIpv6 == nil {
		return ""
	}
	return *t.ValueAsIpv6
}

// GetValueAsMac retrieves the value of the leaf ValueAsMac from the Flow_TaggedMetric_Tags_TagValue
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ValueAsMac is set, it can
// safely use t.GetValueAsMac() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ValueAsMac == nil' before retrieving the leaf's value.
func (t *Flow_TaggedMetric_Tags_TagValue) GetValueAsMac() string {
	if t == nil || t.ValueAsMac == nil {
		return ""
	}
	return *t.ValueAsMac
}

// GetValueAsString retrieves the value of the leaf ValueAsString from the Flow_TaggedMetric_Tags_TagValue
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ValueAsString is set, it can
// safely use t.GetValueAsString() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ValueAsString == nil' before retrieving the leaf's value.
func (t *Flow_TaggedMetric_Tags_TagValue) GetValueAsString() string {
	if t == nil || t.ValueAsString == nil {
		return ""
	}
	return *t.ValueAsString
}

// GetValueType retrieves the value of the leaf ValueType from the Flow_TaggedMetric_Tags_TagValue
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ValueType is set, it can
// safely use t.GetValueType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ValueType == nil' before retrieving the leaf's value.
func (t *Flow_TaggedMetric_Tags_TagValue) GetValueType() E_Tags_ValueType {
	if t == nil || t.ValueType == 0 {
		return 0
	}
	return t.ValueType
}

// PopulateDefaults recursively populates unset leaf fields in the Flow_TaggedMetric_Tags_TagValue
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Flow_TaggedMetric_Tags_TagValue) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Flow_TaggedMetric_Tags_TagValue) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Flow_TaggedMetric_Tags_TagValue"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Flow_TaggedMetric_Tags_TagValue) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Flow_TaggedMetric_Tags_TagValue) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Flow_TaggedMetric_Tags_TagValue.
func (*Flow_TaggedMetric_Tags_TagValue) ΛBelongingModule() string {
	return "open-traffic-generator-flow"
}

// Interface represents the /open-traffic-generator-discovery/interfaces/interface YANG schema element.
type Interface struct {
	ΛMetadata     []ygot.Annotation                  `path:"@" ygotAnnotation:"true"`
	Ipv4Neighbor  map[string]*Interface_Ipv4Neighbor `path:"ipv4-neighbors/ipv4-neighbor" module:"open-traffic-generator-discovery/open-traffic-generator-discovery"`
	ΛIpv4Neighbor []ygot.Annotation                  `path:"ipv4-neighbors/@ipv4-neighbor" ygotAnnotation:"true"`
	Ipv6Neighbor  map[string]*Interface_Ipv6Neighbor `path:"ipv6-neighbors/ipv6-neighbor" module:"open-traffic-generator-discovery/open-traffic-generator-discovery"`
	ΛIpv6Neighbor []ygot.Annotation                  `path:"ipv6-neighbors/@ipv6-neighbor" ygotAnnotation:"true"`
	Name          *string                            `path:"state/name|name" module:"open-traffic-generator-discovery/open-traffic-generator-discovery|open-traffic-generator-discovery"`
	ΛName         []ygot.Annotation                  `path:"state/@name|@name" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Interface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface) IsYANGGoStruct() {}

// NewIpv4Neighbor creates a new entry in the Ipv4Neighbor list of the
// Interface struct. The keys of the list are populated from the input
// arguments.
func (t *Interface) NewIpv4Neighbor(Ipv4Address string) (*Interface_Ipv4Neighbor, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ipv4Neighbor == nil {
		t.Ipv4Neighbor = make(map[string]*Interface_Ipv4Neighbor)
	}

	key := Ipv4Address

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Ipv4Neighbor[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Ipv4Neighbor", key)
	}

	t.Ipv4Neighbor[key] = &Interface_Ipv4Neighbor{
		Ipv4Address: &Ipv4Address,
	}

	return t.Ipv4Neighbor[key], nil
}

// RenameIpv4Neighbor renames an entry in the list Ipv4Neighbor within
// the Interface struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Interface) RenameIpv4Neighbor(oldK, newK string) error {
	if _, ok := t.Ipv4Neighbor[newK]; ok {
		return fmt.Errorf("key %v already exists in Ipv4Neighbor", newK)
	}

	e, ok := t.Ipv4Neighbor[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Ipv4Neighbor", oldK)
	}
	e.Ipv4Address = &newK

	t.Ipv4Neighbor[newK] = e
	delete(t.Ipv4Neighbor, oldK)
	return nil
}

// GetOrCreateIpv4Neighbor retrieves the value with the specified keys from
// the receiver Interface. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Interface) GetOrCreateIpv4Neighbor(Ipv4Address string) *Interface_Ipv4Neighbor {

	key := Ipv4Address

	if v, ok := t.Ipv4Neighbor[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewIpv4Neighbor(Ipv4Address)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateIpv4Neighbor got unexpected error: %v", err))
	}
	return v
}

// GetIpv4Neighbor retrieves the value with the specified key from
// the Ipv4Neighbor map field of Interface. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Interface) GetIpv4Neighbor(Ipv4Address string) *Interface_Ipv4Neighbor {

	if t == nil {
		return nil
	}

	key := Ipv4Address

	if lm, ok := t.Ipv4Neighbor[key]; ok {
		return lm
	}
	return nil
}

// AppendIpv4Neighbor appends the supplied Interface_Ipv4Neighbor struct to the
// list Ipv4Neighbor of Interface. If the key value(s) specified in
// the supplied Interface_Ipv4Neighbor already exist in the list, an error is
// returned.
func (t *Interface) AppendIpv4Neighbor(v *Interface_Ipv4Neighbor) error {
	if v.Ipv4Address == nil {
		return fmt.Errorf("invalid nil key received for Ipv4Address")
	}

	key := *v.Ipv4Address

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ipv4Neighbor == nil {
		t.Ipv4Neighbor = make(map[string]*Interface_Ipv4Neighbor)
	}

	if _, ok := t.Ipv4Neighbor[key]; ok {
		return fmt.Errorf("duplicate key for list Ipv4Neighbor %v", key)
	}

	t.Ipv4Neighbor[key] = v
	return nil
}

// NewIpv6Neighbor creates a new entry in the Ipv6Neighbor list of the
// Interface struct. The keys of the list are populated from the input
// arguments.
func (t *Interface) NewIpv6Neighbor(Ipv6Address string) (*Interface_Ipv6Neighbor, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ipv6Neighbor == nil {
		t.Ipv6Neighbor = make(map[string]*Interface_Ipv6Neighbor)
	}

	key := Ipv6Address

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Ipv6Neighbor[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Ipv6Neighbor", key)
	}

	t.Ipv6Neighbor[key] = &Interface_Ipv6Neighbor{
		Ipv6Address: &Ipv6Address,
	}

	return t.Ipv6Neighbor[key], nil
}

// RenameIpv6Neighbor renames an entry in the list Ipv6Neighbor within
// the Interface struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Interface) RenameIpv6Neighbor(oldK, newK string) error {
	if _, ok := t.Ipv6Neighbor[newK]; ok {
		return fmt.Errorf("key %v already exists in Ipv6Neighbor", newK)
	}

	e, ok := t.Ipv6Neighbor[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Ipv6Neighbor", oldK)
	}
	e.Ipv6Address = &newK

	t.Ipv6Neighbor[newK] = e
	delete(t.Ipv6Neighbor, oldK)
	return nil
}

// GetOrCreateIpv6Neighbor retrieves the value with the specified keys from
// the receiver Interface. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Interface) GetOrCreateIpv6Neighbor(Ipv6Address string) *Interface_Ipv6Neighbor {

	key := Ipv6Address

	if v, ok := t.Ipv6Neighbor[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewIpv6Neighbor(Ipv6Address)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateIpv6Neighbor got unexpected error: %v", err))
	}
	return v
}

// GetIpv6Neighbor retrieves the value with the specified key from
// the Ipv6Neighbor map field of Interface. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Interface) GetIpv6Neighbor(Ipv6Address string) *Interface_Ipv6Neighbor {

	if t == nil {
		return nil
	}

	key := Ipv6Address

	if lm, ok := t.Ipv6Neighbor[key]; ok {
		return lm
	}
	return nil
}

// AppendIpv6Neighbor appends the supplied Interface_Ipv6Neighbor struct to the
// list Ipv6Neighbor of Interface. If the key value(s) specified in
// the supplied Interface_Ipv6Neighbor already exist in the list, an error is
// returned.
func (t *Interface) AppendIpv6Neighbor(v *Interface_Ipv6Neighbor) error {
	if v.Ipv6Address == nil {
		return fmt.Errorf("invalid nil key received for Ipv6Address")
	}

	key := *v.Ipv6Address

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ipv6Neighbor == nil {
		t.Ipv6Neighbor = make(map[string]*Interface_Ipv6Neighbor)
	}

	if _, ok := t.Ipv6Neighbor[key]; ok {
		return fmt.Errorf("duplicate key for list Ipv6Neighbor %v", key)
	}

	t.Ipv6Neighbor[key] = v
	return nil
}

// GetName retrieves the value of the leaf Name from the Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *Interface) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// PopulateDefaults recursively populates unset leaf fields in the Interface
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Ipv4Neighbor {
		e.PopulateDefaults()
	}
	for _, e := range t.Ipv6Neighbor {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the Interface struct, which is a YANG list entry.
func (t *Interface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface.
func (*Interface) ΛBelongingModule() string {
	return "open-traffic-generator-discovery"
}

// Interface_Ipv4Neighbor represents the /open-traffic-generator-discovery/interfaces/interface/ipv4-neighbors/ipv4-neighbor YANG schema element.
type Interface_Ipv4Neighbor struct {
	ΛMetadata         []ygot.Annotation `path:"@" ygotAnnotation:"true"`
	Ipv4Address       *string           `path:"state/ipv4-address|ipv4-address" module:"open-traffic-generator-discovery/open-traffic-generator-discovery|open-traffic-generator-discovery"`
	ΛIpv4Address      []ygot.Annotation `path:"state/@ipv4-address|@ipv4-address" ygotAnnotation:"true"`
	LinkLayerAddress  *string           `path:"state/link-layer-address" module:"open-traffic-generator-discovery/open-traffic-generator-discovery"`
	ΛLinkLayerAddress []ygot.Annotation `path:"state/@link-layer-address" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Interface_Ipv4Neighbor implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Ipv4Neighbor) IsYANGGoStruct() {}

// GetIpv4Address retrieves the value of the leaf Ipv4Address from the Interface_Ipv4Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ipv4Address is set, it can
// safely use t.GetIpv4Address() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ipv4Address == nil' before retrieving the leaf's value.
func (t *Interface_Ipv4Neighbor) GetIpv4Address() string {
	if t == nil || t.Ipv4Address == nil {
		return ""
	}
	return *t.Ipv4Address
}

// GetLinkLayerAddress retrieves the value of the leaf LinkLayerAddress from the Interface_Ipv4Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LinkLayerAddress is set, it can
// safely use t.GetLinkLayerAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LinkLayerAddress == nil' before retrieving the leaf's value.
func (t *Interface_Ipv4Neighbor) GetLinkLayerAddress() string {
	if t == nil || t.LinkLayerAddress == nil {
		return ""
	}
	return *t.LinkLayerAddress
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Ipv4Neighbor
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Ipv4Neighbor) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the Interface_Ipv4Neighbor struct, which is a YANG list entry.
func (t *Interface_Ipv4Neighbor) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Ipv4Address == nil {
		return nil, fmt.Errorf("nil value for key Ipv4Address")
	}

	return map[string]interface{}{
		"ipv4-address": *t.Ipv4Address,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Ipv4Neighbor) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Ipv4Neighbor"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Ipv4Neighbor) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Ipv4Neighbor) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Ipv4Neighbor.
func (*Interface_Ipv4Neighbor) ΛBelongingModule() string {
	return "open-traffic-generator-discovery"
}

// Interface_Ipv6Neighbor represents the /open-traffic-generator-discovery/interfaces/interface/ipv6-neighbors/ipv6-neighbor YANG schema element.
type Interface_Ipv6Neighbor struct {
	ΛMetadata         []ygot.Annotation `path:"@" ygotAnnotation:"true"`
	Ipv6Address       *string           `path:"state/ipv6-address|ipv6-address" module:"open-traffic-generator-discovery/open-traffic-generator-discovery|open-traffic-generator-discovery"`
	ΛIpv6Address      []ygot.Annotation `path:"state/@ipv6-address|@ipv6-address" ygotAnnotation:"true"`
	LinkLayerAddress  *string           `path:"state/link-layer-address" module:"open-traffic-generator-discovery/open-traffic-generator-discovery"`
	ΛLinkLayerAddress []ygot.Annotation `path:"state/@link-layer-address" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Interface_Ipv6Neighbor implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Ipv6Neighbor) IsYANGGoStruct() {}

// GetIpv6Address retrieves the value of the leaf Ipv6Address from the Interface_Ipv6Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ipv6Address is set, it can
// safely use t.GetIpv6Address() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ipv6Address == nil' before retrieving the leaf's value.
func (t *Interface_Ipv6Neighbor) GetIpv6Address() string {
	if t == nil || t.Ipv6Address == nil {
		return ""
	}
	return *t.Ipv6Address
}

// GetLinkLayerAddress retrieves the value of the leaf LinkLayerAddress from the Interface_Ipv6Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LinkLayerAddress is set, it can
// safely use t.GetLinkLayerAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LinkLayerAddress == nil' before retrieving the leaf's value.
func (t *Interface_Ipv6Neighbor) GetLinkLayerAddress() string {
	if t == nil || t.LinkLayerAddress == nil {
		return ""
	}
	return *t.LinkLayerAddress
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Ipv6Neighbor
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Ipv6Neighbor) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the Interface_Ipv6Neighbor struct, which is a YANG list entry.
func (t *Interface_Ipv6Neighbor) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Ipv6Address == nil {
		return nil, fmt.Errorf("nil value for key Ipv6Address")
	}

	return map[string]interface{}{
		"ipv6-address": *t.Ipv6Address,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Ipv6Neighbor) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Ipv6Neighbor"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Ipv6Neighbor) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Ipv6Neighbor) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Ipv6Neighbor.
func (*Interface_Ipv6Neighbor) ΛBelongingModule() string {
	return "open-traffic-generator-discovery"
}

// Port represents the /open-traffic-generator-port/ports/port YANG schema element.
type Port struct {
	ΛMetadata []ygot.Annotation `path:"@" ygotAnnotation:"true"`
	Counters  *Port_Counters    `path:"state/counters" module:"open-traffic-generator-port/open-traffic-generator-port"`
	ΛCounters []ygot.Annotation `path:"state/@counters" ygotAnnotation:"true"`
	InRate    Binary            `path:"state/in-rate" module:"open-traffic-generator-port/open-traffic-generator-port"`
	ΛInRate   []ygot.Annotation `path:"state/@in-rate" ygotAnnotation:"true"`
	Link      E_Port_Link       `path:"state/link" module:"open-traffic-generator-port/open-traffic-generator-port"`
	ΛLink     []ygot.Annotation `path:"state/@link" ygotAnnotation:"true"`
	Name      *string           `path:"state/name|name" module:"open-traffic-generator-port/open-traffic-generator-port|open-traffic-generator-port"`
	ΛName     []ygot.Annotation `path:"state/@name|@name" ygotAnnotation:"true"`
	OutRate   Binary            `path:"state/out-rate" module:"open-traffic-generator-port/open-traffic-generator-port"`
	ΛOutRate  []ygot.Annotation `path:"state/@out-rate" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Port implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Port) IsYANGGoStruct() {}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *Port) GetOrCreateCounters() *Port_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &Port_Counters{}
	return t.Counters
}

// GetCounters returns the value of the Counters struct pointer
// from Port. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Port) GetCounters() *Port_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetInRate retrieves the value of the leaf InRate from the Port
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InRate is set, it can
// safely use t.GetInRate() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InRate == nil' before retrieving the leaf's value.
func (t *Port) GetInRate() Binary {
	if t == nil || t.InRate == nil {
		return nil
	}
	return t.InRate
}

// GetLink retrieves the value of the leaf Link from the Port
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Link is set, it can
// safely use t.GetLink() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Link == nil' before retrieving the leaf's value.
func (t *Port) GetLink() E_Port_Link {
	if t == nil || t.Link == 0 {
		return 0
	}
	return t.Link
}

// GetName retrieves the value of the leaf Name from the Port
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *Port) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetOutRate retrieves the value of the leaf OutRate from the Port
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutRate is set, it can
// safely use t.GetOutRate() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutRate == nil' before retrieving the leaf's value.
func (t *Port) GetOutRate() Binary {
	if t == nil || t.OutRate == nil {
		return nil
	}
	return t.OutRate
}

// PopulateDefaults recursively populates unset leaf fields in the Port
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Port) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Counters.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the Port struct, which is a YANG list entry.
func (t *Port) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Port) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Port"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Port) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Port) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Port.
func (*Port) ΛBelongingModule() string {
	return "open-traffic-generator-port"
}

// Port_Counters represents the /open-traffic-generator-port/ports/port/state/counters YANG schema element.
type Port_Counters struct {
	ΛMetadata  []ygot.Annotation `path:"@" ygotAnnotation:"true"`
	InFrames   *uint64           `path:"in-frames" module:"open-traffic-generator-port"`
	ΛInFrames  []ygot.Annotation `path:"@in-frames" ygotAnnotation:"true"`
	InOctets   *uint64           `path:"in-octets" module:"open-traffic-generator-port"`
	ΛInOctets  []ygot.Annotation `path:"@in-octets" ygotAnnotation:"true"`
	OutFrames  *uint64           `path:"out-frames" module:"open-traffic-generator-port"`
	ΛOutFrames []ygot.Annotation `path:"@out-frames" ygotAnnotation:"true"`
	OutOctets  *uint64           `path:"out-octets" module:"open-traffic-generator-port"`
	ΛOutOctets []ygot.Annotation `path:"@out-octets" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Port_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Port_Counters) IsYANGGoStruct() {}

// GetInFrames retrieves the value of the leaf InFrames from the Port_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InFrames is set, it can
// safely use t.GetInFrames() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InFrames == nil' before retrieving the leaf's value.
func (t *Port_Counters) GetInFrames() uint64 {
	if t == nil || t.InFrames == nil {
		return 0
	}
	return *t.InFrames
}

// GetInOctets retrieves the value of the leaf InOctets from the Port_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InOctets is set, it can
// safely use t.GetInOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InOctets == nil' before retrieving the leaf's value.
func (t *Port_Counters) GetInOctets() uint64 {
	if t == nil || t.InOctets == nil {
		return 0
	}
	return *t.InOctets
}

// GetOutFrames retrieves the value of the leaf OutFrames from the Port_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutFrames is set, it can
// safely use t.GetOutFrames() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutFrames == nil' before retrieving the leaf's value.
func (t *Port_Counters) GetOutFrames() uint64 {
	if t == nil || t.OutFrames == nil {
		return 0
	}
	return *t.OutFrames
}

// GetOutOctets retrieves the value of the leaf OutOctets from the Port_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutOctets is set, it can
// safely use t.GetOutOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutOctets == nil' before retrieving the leaf's value.
func (t *Port_Counters) GetOutOctets() uint64 {
	if t == nil || t.OutOctets == nil {
		return 0
	}
	return *t.OutOctets
}

// PopulateDefaults recursively populates unset leaf fields in the Port_Counters
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Port_Counters) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Port_Counters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Port_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Port_Counters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Port_Counters) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Port_Counters.
func (*Port_Counters) ΛBelongingModule() string {
	return "open-traffic-generator-port"
}

// E_Port_Link is a derived int64 type which is used to represent
// the enumerated node Port_Link. An additional value named
// Port_Link_UNSET is added to the enumeration which is used as
// the nil value, indicating that the enumeration was not explicitly set by
// the program importing the generated structures.
type E_Port_Link int64

// IsYANGGoEnum ensures that Port_Link implements the yang.GoEnum
// interface. This ensures that Port_Link can be identified as a
// mapped type for a YANG enumeration.
func (E_Port_Link) IsYANGGoEnum() {}

// ΛMap returns the value lookup map associated with  Port_Link.
func (E_Port_Link) ΛMap() map[string]map[int64]ygot.EnumDefinition { return ΛEnum }

// String returns a logging-friendly string for E_Port_Link.
func (e E_Port_Link) String() string {
	return ygot.EnumLogString(e, int64(e), "E_Port_Link")
}

const (
	// Port_Link_UNSET corresponds to the value UNSET of Port_Link
	Port_Link_UNSET E_Port_Link = 0
	// Port_Link_UP corresponds to the value UP of Port_Link
	Port_Link_UP E_Port_Link = 1
	// Port_Link_DOWN corresponds to the value DOWN of Port_Link
	Port_Link_DOWN E_Port_Link = 2
)

// E_Tags_ValueType is a derived int64 type which is used to represent
// the enumerated node Tags_ValueType. An additional value named
// Tags_ValueType_UNSET is added to the enumeration which is used as
// the nil value, indicating that the enumeration was not explicitly set by
// the program importing the generated structures.
type E_Tags_ValueType int64

// IsYANGGoEnum ensures that Tags_ValueType implements the yang.GoEnum
// interface. This ensures that Tags_ValueType can be identified as a
// mapped type for a YANG enumeration.
func (E_Tags_ValueType) IsYANGGoEnum() {}

// ΛMap returns the value lookup map associated with  Tags_ValueType.
func (E_Tags_ValueType) ΛMap() map[string]map[int64]ygot.EnumDefinition { return ΛEnum }

// String returns a logging-friendly string for E_Tags_ValueType.
func (e E_Tags_ValueType) String() string {
	return ygot.EnumLogString(e, int64(e), "E_Tags_ValueType")
}

const (
	// Tags_ValueType_UNSET corresponds to the value UNSET of Tags_ValueType
	Tags_ValueType_UNSET E_Tags_ValueType = 0
	// Tags_ValueType_STRING corresponds to the value STRING of Tags_ValueType
	Tags_ValueType_STRING E_Tags_ValueType = 1
	// Tags_ValueType_HEX corresponds to the value HEX of Tags_ValueType
	Tags_ValueType_HEX E_Tags_ValueType = 2
	// Tags_ValueType_BOOL corresponds to the value BOOL of Tags_ValueType
	Tags_ValueType_BOOL E_Tags_ValueType = 3
	// Tags_ValueType_COUNTER64 corresponds to the value COUNTER64 of Tags_ValueType
	Tags_ValueType_COUNTER64 E_Tags_ValueType = 4
	// Tags_ValueType_FLOAT32 corresponds to the value FLOAT32 of Tags_ValueType
	Tags_ValueType_FLOAT32 E_Tags_ValueType = 5
	// Tags_ValueType_IPV4 corresponds to the value IPV4 of Tags_ValueType
	Tags_ValueType_IPV4 E_Tags_ValueType = 6
	// Tags_ValueType_IPV6 corresponds to the value IPV6 of Tags_ValueType
	Tags_ValueType_IPV6 E_Tags_ValueType = 7
	// Tags_ValueType_MAC corresponds to the value MAC of Tags_ValueType
	Tags_ValueType_MAC E_Tags_ValueType = 8
)

// ΛEnum is a map, keyed by the name of the type defined for each enum in the
// generated Go code, which provides a mapping between the constant int64 value
// of each value of the enumeration, and the string that is used to represent it
// in the YANG schema. The map is named ΛEnum in order to avoid clash with any
// valid YANG identifier.
var ΛEnum = map[string]map[int64]ygot.EnumDefinition{
	"E_Port_Link": {
		1: {Name: "UP"},
		2: {Name: "DOWN"},
	},
	"E_Tags_ValueType": {
		1: {Name: "STRING"},
		2: {Name: "HEX"},
		3: {Name: "BOOL"},
		4: {Name: "COUNTER64"},
		5: {Name: "FLOAT32"},
		6: {Name: "IPV4"},
		7: {Name: "IPV6"},
		8: {Name: "MAC"},
	},
}

var (
	// ySchema is a byte slice contain a gzip compressed representation of the
	// YANG schema from which the Go code was generated. When uncompressed the
	// contents of the byte slice is a JSON document containing an object, keyed
	// on the name of the generated struct, and containing the JSON marshalled
	// contents of a goyang yang.Entry struct, which defines the schema for the
	// fields within the struct.
	ySchema = []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x5d, 0x5b, 0x73, 0xda, 0x48,
		0xd3, 0xbe, 0xf7, 0xaf, 0x50, 0xe9, 0x2a, 0xfe, 0xca, 0x8a, 0x8d, 0x8d, 0xe5, 0x84, 0x3b, 0xaf,
		0x93, 0x7c, 0x9b, 0xda, 0x1c, 0x5c, 0x89, 0xb3, 0xef, 0x5b, 0x95, 0x75, 0x6d, 0xcd, 0xe2, 0x81,
		0xa8, 0x02, 0x92, 0x4b, 0x1a, 0xbc, 0x76, 0xc5, 0xfc, 0xf7, 0xb7, 0x24, 0x40, 0x20, 0x84, 0x60,
		0x0e, 0x3d, 0x20, 0xe0, 0xc9, 0x85, 0x63, 0xc3, 0x4c, 0x8f, 0x34, 0x7d, 0x78, 0x7a, 0xa6, 0x7b,
		0x7a, 0x7e, 0x1d, 0x38, 0x8e, 0xe3, 0xb8, 0x9f, 0x58, 0x9f, 0xbb, 0x2d, 0xc7, 0xbd, 0xe3, 0x0f,
		0x41, 0x9b, 0xbb, 0x47, 0xa3, 0x4f, 0xff, 0x08, 0xc2, 0x3b, 0xb7, 0xe5, 0x34, 0xc6, 0x7f, 0x5e,
		0x45, 0x61, 0x27, 0xe8, 0xba, 0x2d, 0xe7, 0x64, 0xfc, 0xc1, 0x9b, 0x20, 0x76, 0x5b, 0xce, 0x88,
		0x44, 0xf6, 0x41, 0xa7, 0x17, 0xfd, 0x9b, 0x14, 0x3e, 0x2a, 0x50, 0x1f, 0x7d, 0x7d, 0x54, 0xfc,
		0xb2, 0x38, 0x48, 0xfe, 0xf1, 0xfc, 0x60, 0xf9, 0x17, 0xd7, 0x31, 0xef, 0x04, 0x8f, 0xa5, 0x41,
		0x0a, 0x03, 0x45, 0xa2, 0xeb, 0xa5, 0x83, 0xcd, 0x8d, 0x95, 0xb5, 0xf9, 0x1a, 0x0d, 0xe2, 0x36,
		0x5f, 0xd8, 0x7f, 0xf4, 0x3c, 0xfc, 0xe9, 0xdf, 0x28, 0x4e, 0x1f, 0xc9, 0xbd, 0x1f, 0x0d, 0x75,
		0xb4, 0xb8, 0xe1, 0xef, 0x2c, 0xb9, 0x8c, 0xbb, 0x83, 0x3e, 0x0f, 0x85, 0xdb, 0x72, 0x44, 0x3c,
		0xe0, 0x15, 0x0d, 0x67, 0x5a, 0x4d, 0x9f, 0xac, 0xd4, 0x74, 0x58, 0xf8, 0x64, 0x38, 0xf7, 0xd6,
		0xf3, 0x53, 0x5d, 0x98, 0xf2, 0xea, 0x97, 0x99, 0x9d, 0xf9, 0xaa, 0xf7, 0x58, 0xcc, 0x80, 0x32,
		0x23, 0x4e, 0x2b, 0x1a, 0x2c, 0x61, 0x88, 0x0a, 0x63, 0x64, 0x19, 0xa4, 0xcc, 0x28, 0x65, 0x86,
		0x29, 0x32, 0x6e, 0x31, 0x03, 0x2b, 0x18, 0xb9, 0x92, 0xa1, 0x79, 0x83, 0x70, 0x34, 0x65, 0x2b,
		0x26, 0x61, 0x32, 0xb1, 0x59, 0xeb, 0x15, 0xaf, 0x33, 0x66, 0xf4, 0xc9, 0x8a, 0x66, 0x55, 0x9a,
		0xa7, 0xc3, 0x78, 0x1d, 0x01, 0x50, 0x15, 0x04, 0x6d, 0x81, 0xd0, 0x16, 0x0c, 0x4d, 0x01, 0x59,
		0x2e, 0x28, 0x2b, 0x04, 0x26, 0x1f, 0xf3, 0xe6, 0xe9, 0x9e, 0xab, 0xcd, 0x79, 0x8f, 0xb3, 0x4e,
		0xcc, 0x3b, 0x32, 0x53, 0x3e, 0xb1, 0x05, 0x17, 0x12, 0x6d, 0xaf, 0x99, 0xf8, 0x91, 0x92, 0x7f,
		0xf9, 0xf2, 0x38, 0x11, 0x4c, 0xf0, 0xe3, 0x4c, 0x06, 0x0f, 0xf4, 0xde, 0x7c, 0xc9, 0x5b, 0xbb,
		0x19, 0x75, 0x79, 0x55, 0x18, 0x35, 0x97, 0xd3, 0x85, 0x86, 0xac, 0x2e, 0x9c, 0x42, 0x17, 0x6a,
		0xa8, 0x0b, 0xab, 0x8c, 0x68, 0xde, 0x90, 0x3d, 0xf0, 0x98, 0x75, 0xb9, 0xd7, 0x63, 0x82, 0x87,
		0xed, 0x27, 0xf9, 0x79, 0x9c, 0xf0, 0x6a, 0x9e, 0x80, 0xe4, 0xa4, 0xc8, 0x99, 0x5c, 0x65, 0xd3,
		0xab, 0x23, 0x76, 0x26, 0xe2, 0xa7, 0x2b, 0x86, 0xc6, 0xe2, 0x68, 0x2c, 0x96, 0x86, 0xe2, 0x29,
		0x27, 0xa6, 0x92, 0xe2, 0xaa, 0x6e, 0xc2, 0x4b, 0x3c, 0x13, 0x41, 0x9f, 0x8b, 0xa0, 0xfd, 0x33,
		0xf1, 0x9b, 0x2a, 0x6c, 0x1b, 0x8b, 0xe1, 0x2b, 0x85, 0x2e, 0xdf, 0xc2, 0x40, 0x24, 0x23, 0xcf,
		0x22, 0x8c, 0x12, 0xde, 0x8e, 0xc2, 0xbb, 0x44, 0x65, 0xc8, 0x2f, 0x2c, 0xec, 0xa6, 0x8f, 0xfc,
		0x5d, 0x89, 0x4d, 0x6a, 0x62, 0x95, 0x0d, 0xf4, 0x31, 0x08, 0x95, 0xe5, 0x31, 0xef, 0xfc, 0x27,
		0xeb, 0x0d, 0xb8, 0xbc, 0xbe, 0x95, 0xfa, 0xbf, 0x8b, 0x59, 0x5b, 0x04, 0x51, 0xf8, 0x26, 0xe8,
		0x8e, 0xa6, 0x4b, 0x97, 0xd0, 0x27, 0xde, 0x65, 0x22, 0x78, 0x48, 0x9f, 0xa5, 0xc3, 0x7a, 0x09,
		0x57, 0xa6, 0x32, 0x3c, 0xd2, 0x98, 0x3a, 0xf6, 0x68, 0x3e, 0x75, 0x8d, 0x57, 0xcd, 0xa6, 0x7f,
		0xd1, 0x6c, 0x9e, 0x5c, 0x9c, 0x5d, 0x9c, 0xbc, 0x3e, 0x3f, 0x6f, 0xf8, 0x8d, 0xf3, 0xed, 0x9f,
		0xcd, 0x03, 0x3b, 0xad, 0x6f, 0x0f, 0x68, 0xe8, 0x49, 0x70, 0xdb, 0x6d, 0x47, 0x83, 0x50, 0xf0,
		0x38, 0x51, 0x07, 0xbb, 0xbc, 0xa7, 0x1a, 0xca, 0x35, 0x80, 0x72, 0x40, 0x39, 0x75, 0xe7, 0x2c,
		0xef, 0x10, 0x84, 0x5e, 0xd4, 0x16, 0x5c, 0x24, 0xea, 0x33, 0x3f, 0xe1, 0xf6, 0x94, 0x84, 0xe2,
		0xc4, 0xa9, 0x39, 0x6a, 0xda, 0xa2, 0x6c, 0x22, 0xd2, 0x14, 0xa2, 0x6d, 0x2a, 0xe2, 0x64, 0xa2,
		0x4e, 0x26, 0xf2, 0x44, 0xa2, 0xaf, 0x69, 0xf8, 0x15, 0xb9, 0xae, 0xec, 0xf8, 0x55, 0x99, 0x66,
		0x25, 0xf7, 0xcf, 0xc0, 0x0d, 0x34, 0x74, 0xe7, 0xf4, 0xdd, 0x3a, 0x12, 0xf7, 0x8e, 0xca, 0xcd,
		0x23, 0x77, 0x50, 0xe8, 0x1c, 0x15, 0x03, 0xf7, 0x8f, 0xc4, 0x0d, 0xb4, 0xe8, 0x0e, 0x6e, 0xc3,
		0xac, 0x1f, 0xac, 0xa7, 0xd7, 0xad, 0x25, 0x77, 0x54, 0x41, 0x6a, 0x52, 0x68, 0xbd, 0xff, 0x69,
		0x88, 0xcd, 0x19, 0x01, 0x20, 0x33, 0x90, 0x19, 0xc8, 0x0c, 0x64, 0x06, 0x32, 0x03, 0x99, 0x81,
		0xcc, 0x04, 0xc8, 0x1c, 0x0d, 0x84, 0xf1, 0xc2, 0x79, 0x86, 0x06, 0xf0, 0x19, 0xf8, 0x0c, 0x7c,
		0x06, 0x3e, 0x03, 0x9f, 0x81, 0xcf, 0xc0, 0x67, 0x22, 0x7c, 0x36, 0x5b, 0x3a, 0xe7, 0x14, 0x80,
		0xcd, 0xc0, 0x66, 0x60, 0x33, 0xb0, 0x19, 0xd8, 0x0c, 0x6c, 0x06, 0x36, 0x1b, 0xb5, 0x94, 0x0d,
		0x63, 0x5f, 0x86, 0x61, 0x24, 0x58, 0xca, 0x29, 0xb5, 0x68, 0x76, 0xd2, 0xfe, 0xc1, 0xfb, 0xec,
		0x7e, 0x9c, 0x24, 0x7b, 0x1c, 0xdd, 0xf3, 0xd0, 0x13, 0x31, 0xeb, 0x74, 0x82, 0xb6, 0xd7, 0xe5,
		0x21, 0x8f, 0x99, 0x88, 0xe2, 0xcc, 0x9e, 0x1f, 0x67, 0xe7, 0x22, 0xb2, 0x9f, 0xe3, 0x4c, 0x5a,
		0xc5, 0x04, 0x8c, 0xd1, 0x78, 0x22, 0x1e, 0xb4, 0xc5, 0x38, 0x6b, 0xdc, 0x7d, 0xd7, 0x8b, 0xfe,
		0xfd, 0xfb, 0x6a, 0x42, 0x66, 0x8d, 0x59, 0x27, 0x41, 0xe8, 0x75, 0x62, 0xd6, 0xe7, 0x5e, 0x2c,
		0x93, 0xb4, 0x5b, 0x42, 0x82, 0x62, 0x77, 0x64, 0x59, 0xae, 0xd5, 0x7d, 0x41, 0x96, 0xe5, 0x58,
		0x08, 0x39, 0xe7, 0x9d, 0x5e, 0xc4, 0xc4, 0xd9, 0xa9, 0x46, 0x96, 0xe5, 0x6b, 0x85, 0x2e, 0x1f,
		0x78, 0xd8, 0xcd, 0x0c, 0xc4, 0x76, 0xa4, 0x49, 0x36, 0x91, 0x26, 0xb9, 0xc7, 0x53, 0xb7, 0x03,
		0x39, 0x91, 0x41, 0xa8, 0x8f, 0x4b, 0x40, 0x24, 0x20, 0x12, 0x10, 0x09, 0x88, 0x04, 0x44, 0x02,
		0x22, 0xd1, 0x21, 0x52, 0x2f, 0x4a, 0x12, 0xef, 0xbe, 0x2d, 0xd4, 0x21, 0x29, 0xef, 0x09, 0x4c,
		0x02, 0x26, 0x01, 0x93, 0x80, 0x49, 0xc0, 0x24, 0x60, 0x12, 0x09, 0x26, 0xf5, 0xd9, 0x63, 0xd0,
		0x1f, 0xf4, 0xf5, 0x4f, 0x4b, 0xcf, 0x13, 0x00, 0x42, 0x01, 0xa1, 0x36, 0x80, 0x50, 0x38, 0x2d,
		0x6d, 0x07, 0xe0, 0x70, 0x5a, 0x5a, 0x7b, 0xea, 0x70, 0x5a, 0xba, 0xae, 0x98, 0x17, 0x84, 0x86,
		0x98, 0x37, 0x47, 0x00, 0x98, 0x07, 0xcc, 0x03, 0xe6, 0x01, 0xf3, 0x80, 0x79, 0xc0, 0xbc, 0x9a,
		0x62, 0x9e, 0x54, 0x89, 0xc1, 0x92, 0x85, 0x91, 0x28, 0x35, 0x08, 0x74, 0x03, 0xba, 0x59, 0x41,
		0xb7, 0x44, 0xc4, 0x41, 0xd8, 0xd5, 0x00, 0xb6, 0xc6, 0xab, 0x35, 0xea, 0x55, 0x34, 0x10, 0x46,
		0x49, 0x50, 0x73, 0xfd, 0xa1, 0x6b, 0xd0, 0xb5, 0x0d, 0xe8, 0x1a, 0xf6, 0xf7, 0x2b, 0xfc, 0x19,
		0xec, 0xef, 0xef, 0xf3, 0xd4, 0xed, 0x80, 0xdf, 0x97, 0xe2, 0x8b, 0x3e, 0x32, 0x01, 0x93, 0x80,
		0x49, 0xc0, 0x24, 0x60, 0x12, 0x30, 0x09, 0x98, 0x44, 0x87, 0x49, 0x22, 0x66, 0x61, 0xd2, 0x0f,
		0x34, 0xf2, 0xa0, 0xf2, 0x9e, 0xc0, 0x24, 0x60, 0xd2, 0x06, 0x30, 0xe9, 0x9f, 0x28, 0xea, 0x71,
		0x16, 0xea, 0x6c, 0x4a, 0x34, 0xa8, 0x14, 0xcc, 0xa8, 0x8a, 0xbe, 0xe2, 0x09, 0x37, 0x93, 0x93,
		0x6d, 0x36, 0xae, 0x87, 0x10, 0xac, 0xdb, 0xe5, 0x77, 0x5e, 0x9f, 0x8b, 0x38, 0x68, 0x27, 0xf2,
		0xf7, 0x44, 0xcc, 0xf5, 0x23, 0xbe, 0x30, 0x02, 0x97, 0xa7, 0xd8, 0xd1, 0xfe, 0x35, 0x5d, 0x18,
		0x51, 0x10, 0x0e, 0x0d, 0x4c, 0x2a, 0x74, 0x47, 0x19, 0x6d, 0x00, 0x93, 0x36, 0x30, 0x29, 0x97,
		0xd1, 0x0e, 0x59, 0x9f, 0x7b, 0x0f, 0xa9, 0x73, 0xeb, 0xdd, 0xb3, 0x20, 0x36, 0x28, 0x3b, 0x52,
		0xa2, 0x84, 0xf2, 0x23, 0x36, 0x04, 0x9e, 0x4c, 0xf0, 0xc9, 0x14, 0x80, 0x48, 0x11, 0x34, 0xd7,
		0x27, 0x6b, 0x2f, 0x3f, 0x22, 0x7f, 0x41, 0x56, 0xa5, 0xcd, 0xbe, 0xd0, 0xe8, 0xbb, 0xf0, 0x02,
		0xad, 0x82, 0xbe, 0xd5, 0xa0, 0x78, 0x91, 0xdc, 0xe5, 0x5b, 0x95, 0x53, 0x2b, 0x73, 0x19, 0x97,
		0x21, 0x10, 0xc2, 0x6e, 0xc0, 0x6e, 0xe8, 0xd8, 0x0d, 0x55, 0x60, 0xcd, 0x3b, 0x2a, 0x5f, 0xac,
		0x52, 0x29, 0x34, 0x1a, 0x75, 0x3e, 0x08, 0x14, 0xc5, 0x58, 0x61, 0x28, 0x14, 0x87, 0x52, 0x81,
		0xa8, 0x14, 0x89, 0x5c, 0xa1, 0xc8, 0x15, 0x8b, 0x58, 0xc1, 0xf4, 0x14, 0xcd, 0x60, 0xc7, 0xd6,
		0x48, 0xf1, 0x72, 0x02, 0xfa, 0x17, 0xc5, 0x54, 0x4a, 0x9f, 0xee, 0xc5, 0x31, 0x44, 0x3e, 0x2f,
		0xb9, 0x6a, 0x52, 0xaa, 0xa8, 0x0d, 0x55, 0xa5, 0x56, 0x59, 0x6b, 0xaa, 0x6b, 0x4d, 0x85, 0x2d,
		0xa9, 0xb2, 0x99, 0x4a, 0x1b, 0xaa, 0xb6, 0xb9, 0x4f, 0xbe, 0x0a, 0x2a, 0xb5, 0x4a, 0x04, 0x56,
		0x29, 0xe9, 0x2b, 0x02, 0x52, 0x66, 0x25, 0x04, 0xe7, 0xff, 0xd1, 0x28, 0x81, 0x43, 0x55, 0x62,
		0xb0, 0x44, 0x94, 0xa8, 0xe4, 0x60, 0x89, 0x2e, 0x75, 0x31, 0xbc, 0xb2, 0x18, 0x51, 0x15, 0xc7,
		0x23, 0xd6, 0x94, 0x22, 0xcb, 0xd8, 0xa3, 0x3d, 0x96, 0xd1, 0x97, 0x30, 0xdc, 0x25, 0x2e, 0x1e,
		0xd4, 0x83, 0xca, 0xed, 0xc1, 0x66, 0xc6, 0x37, 0x29, 0xb4, 0xa9, 0x7b, 0x31, 0xd0, 0x32, 0x5f,
		0x4c, 0xa3, 0xd8, 0x31, 0x3c, 0x31, 0x78, 0x62, 0xf0, 0xc4, 0xe0, 0x89, 0xc1, 0x13, 0x83, 0x27,
		0x06, 0x4f, 0x0c, 0x9e, 0xd8, 0x1e, 0x7a, 0x62, 0x06, 0x17, 0x41, 0x55, 0x7b, 0x18, 0xba, 0x17,
		0x43, 0xc1, 0x1f, 0x83, 0x3f, 0x06, 0x7f, 0x0c, 0xfe, 0x18, 0xfc, 0x31, 0xf8, 0x63, 0xf0, 0xc7,
		0xe0, 0x8f, 0xed, 0xa9, 0x3f, 0x46, 0xbb, 0x35, 0xa6, 0x79, 0x11, 0x18, 0x7c, 0x31, 0xf8, 0x62,
		0xf0, 0xc5, 0xe0, 0x8b, 0xc1, 0x17, 0x83, 0x2f, 0x06, 0x5f, 0x0c, 0xbe, 0xd8, 0xb6, 0xfa, 0x62,
		0x6b, 0x4d, 0x53, 0xd3, 0xbc, 0xf8, 0xad, 0x44, 0x47, 0xef, 0xb8, 0x5c, 0xf1, 0x74, 0x5a, 0xf1,
		0x4f, 0xfd, 0x5b, 0xe2, 0xca, 0x0f, 0x57, 0xbe, 0x35, 0xee, 0x26, 0x1b, 0xea, 0x63, 0x36, 0x92,
		0xe2, 0x15, 0x72, 0xe6, 0x0c, 0xd3, 0x39, 0x05, 0x6e, 0x7c, 0xe0, 0xa5, 0x04, 0xe3, 0x86, 0x07,
		0x5f, 0x88, 0xdc, 0x6c, 0xe4, 0xe7, 0xae, 0xcb, 0x7d, 0x46, 0x7e, 0x2e, 0xa9, 0x5b, 0xac, 0x5f,
		0xae, 0xad, 0x4a, 0x83, 0x24, 0xcb, 0xb7, 0x6d, 0xc6, 0xfe, 0x08, 0xd6, 0x25, 0xb0, 0x39, 0x19,
		0x15, 0x9c, 0x03, 0x80, 0x9d, 0xd9, 0x1b, 0x3b, 0x63, 0x7c, 0x0e, 0x40, 0xb0, 0xae, 0xa7, 0x54,
		0xc3, 0x54, 0x46, 0x09, 0x3d, 0x85, 0xfa, 0xa6, 0xd8, 0x5f, 0xc3, 0xfe, 0x1a, 0xf6, 0xd7, 0xd6,
		0xb8, 0xbf, 0x66, 0xec, 0x50, 0x10, 0x39, 0x16, 0x04, 0x6b, 0xd9, 0x23, 0x33, 0xbb, 0xf7, 0x30,
		0xde, 0x30, 0x21, 0x34, 0x7c, 0x23, 0x92, 0x34, 0x96, 0xaf, 0x01, 0xcb, 0x07, 0xcb, 0xb7, 0xbf,
		0x96, 0xcf, 0xd4, 0xb5, 0xc9, 0x09, 0x8d, 0x36, 0x21, 0x58, 0xe2, 0xfd, 0x13, 0x45, 0x3d, 0x3a,
		0x29, 0x99, 0x48, 0x72, 0x91, 0x3c, 0x11, 0x43, 0x69, 0x9c, 0x1f, 0x72, 0x53, 0x60, 0xc3, 0x24,
		0xd8, 0x34, 0x0d, 0xb6, 0x4c, 0x84, 0x75, 0x53, 0x61, 0xdd, 0x64, 0x58, 0x36, 0x1d, 0x34, 0x26,
		0x84, 0xc8, 0x94, 0xd0, 0x3b, 0x53, 0x25, 0x99, 0x55, 0x2f, 0x60, 0x27, 0xed, 0x05, 0x34, 0x6a,
		0x12, 0xb1, 0x20, 0x60, 0xc2, 0xd4, 0x56, 0x4e, 0x83, 0xbc, 0xf6, 0xec, 0x31, 0x65, 0x20, 0x19,
		0x46, 0x19, 0x46, 0x19, 0x46, 0x79, 0xcb, 0x8c, 0x32, 0xb5, 0x01, 0x70, 0x68, 0x33, 0x4a, 0x72,
		0x92, 0xb4, 0x99, 0x25, 0x93, 0x7f, 0xb4, 0x4a, 0xe5, 0xd8, 0xca, 0x34, 0xc9, 0x89, 0x5b, 0xca,
		0x38, 0xc9, 0xe9, 0xdb, 0xce, 0x59, 0x98, 0x8a, 0x9f, 0xad, 0xdc, 0x05, 0x62, 0xcd, 0x2b, 0xb2,
		0xd6, 0x42, 0x46, 0x4a, 0x89, 0xb5, 0xf6, 0x33, 0x53, 0x76, 0x91, 0xdb, 0x07, 0xf5, 0xa4, 0x76,
		0xbb, 0x8b, 0x7e, 0xe9, 0xe4, 0x62, 0x04, 0x7b, 0x5e, 0xa9, 0xfa, 0xd5, 0x0b, 0xf0, 0x49, 0xe1,
		0x93, 0xc2, 0x27, 0xdd, 0x11, 0x9f, 0x54, 0xef, 0xf6, 0x15, 0x59, 0x33, 0xf0, 0x9a, 0x90, 0xa4,
		0xe6, 0xed, 0x2d, 0xbb, 0xea, 0x96, 0x36, 0xe1, 0xa8, 0xec, 0xaa, 0x5b, 0x0a, 0xd6, 0xc2, 0x07,
		0xad, 0x91, 0x0f, 0xfa, 0x83, 0x3f, 0x5a, 0xf4, 0x3f, 0x53, 0xea, 0xf0, 0x3d, 0xe1, 0x7b, 0xc2,
		0xf7, 0xdc, 0x3b, 0xdf, 0xf3, 0x07, 0x7f, 0xf4, 0xc8, 0xb2, 0x7f, 0xe6, 0xad, 0x40, 0x83, 0x72,
		0x47, 0xf4, 0x9a, 0x09, 0xc1, 0xe3, 0x90, 0xdc, 0xf9, 0x74, 0xbf, 0x9f, 0x78, 0xaf, 0x99, 0xd7,
		0xb9, 0xf4, 0xde, 0xdd, 0xfe, 0x9f, 0x0b, 0x18, 0x5a, 0x06, 0x43, 0xc1, 0xfd, 0x83, 0xcd, 0xe8,
		0x5c, 0x46, 0x1e, 0x40, 0x04, 0x20, 0x02, 0x10, 0xed, 0xdf, 0x26, 0xc8, 0xfd, 0x43, 0xd3, 0x63,
		0x77, 0x77, 0x31, 0x4f, 0x92, 0xbd, 0x85, 0xa2, 0x17, 0x29, 0x16, 0xdd, 0x3e, 0x7f, 0x6f, 0x78,
		0xaf, 0x6f, 0x47, 0xbf, 0x36, 0xb2, 0xff, 0x7e, 0x9d, 0x0e, 0x9f, 0x4f, 0xbf, 0x9f, 0x78, 0xcd,
		0xf1, 0xa7, 0xa7, 0xe7, 0xdf, 0x4f, 0xbc, 0xf3, 0xdb, 0xc3, 0x17, 0x7f, 0xfd, 0xf5, 0x52, 0xb5,
		0xcf, 0xe1, 0xaf, 0xb3, 0x21, 0x60, 0x6e, 0x15, 0xcc, 0xf9, 0x76, 0x61, 0xce, 0x07, 0xcc, 0x01,
		0xe6, 0x00, 0x73, 0x7b, 0x09, 0x73, 0x3e, 0x60, 0xee, 0xc5, 0xcc, 0x9a, 0xeb, 0x57, 0xe3, 0xa8,
		0x39, 0x6c, 0x1d, 0xfe, 0xba, 0x18, 0xce, 0x7f, 0xf8, 0xbc, 0xa8, 0x59, 0xe3, 0xe8, 0x62, 0xd8,
		0xaa, 0xf8, 0xc6, 0x1f, 0xb6, 0x24, 0x69, 0x9c, 0x0f, 0x5f, 0x94, 0x9a, 0xa6, 0x9f, 0x9f, 0x56,
		0x75, 0x68, 0x56, 0x74, 0x38, 0xab, 0xea, 0x70, 0x56, 0xd1, 0xa1, 0xf2, 0x91, 0x4e, 0x2b, 0x3a,
		0x9c, 0x0f, 0x9f, 0x4b, 0xed, 0x5f, 0x2c, 0x6e, 0xea, 0x0f, 0x0f, 0x9f, 0xab, 0xbe, 0xbb, 0x18,
		0x3e, 0xb7, 0x0e, 0x0f, 0x01, 0xfc, 0x4b, 0x81, 0xbf, 0xcf, 0xda, 0x16, 0x71, 0x3f, 0xa5, 0x0e,
		0xd8, 0x07, 0xec, 0x03, 0xf6, 0xf7, 0x0e, 0xf6, 0xfb, 0xac, 0xbd, 0xf7, 0xa8, 0x3f, 0x8b, 0x4a,
		0xf3, 0x60, 0x77, 0x3a, 0x3c, 0xfc, 0x75, 0x8e, 0x65, 0xe9, 0x72, 0x74, 0x1a, 0xef, 0xd3, 0xdb,
		0x03, 0x28, 0xd2, 0x40, 0x00, 0x30, 0x0a, 0x18, 0x05, 0x8c, 0xda, 0x22, 0x8c, 0xb2, 0x18, 0x06,
		0xdc, 0x39, 0x6b, 0x2c, 0x28, 0xb9, 0x30, 0x67, 0x88, 0x33, 0xda, 0xb0, 0xc1, 0xb0, 0xc1, 0xb0,
		0xc1, 0x7b, 0x67, 0x83, 0x79, 0x38, 0xe8, 0xf3, 0x78, 0x54, 0x1d, 0xd3, 0x82, 0x21, 0x26, 0xcc,
		0x6a, 0x74, 0xdf, 0x86, 0x83, 0x3e, 0xbd, 0x22, 0xdc, 0x44, 0x5f, 0x69, 0xbd, 0xdc, 0x02, 0xf5,
		0x93, 0x74, 0x8e, 0xbf, 0xde, 0x7c, 0x79, 0xff, 0xe9, 0xff, 0x5d, 0x0b, 0x99, 0xa9, 0x8d, 0x94,
		0xfc, 0xef, 0x6f, 0xff, 0x6b, 0x83, 0xf6, 0x69, 0x4a, 0xfb, 0xb7, 0xcf, 0x9f, 0x3f, 0xd8, 0x20,
		0x7e, 0x96, 0x12, 0xbf, 0xfa, 0xfc, 0xed, 0xd3, 0xcd, 0xdb, 0x2f, 0xa4, 0x47, 0x23, 0xf3, 0x11,
		0x9a, 0x59, 0x1d, 0xd4, 0x0f, 0x9f, 0x2f, 0x6f, 0x48, 0x93, 0xdc, 0x73, 0xfa, 0xe7, 0x29, 0xfd,
		0xf7, 0xd7, 0x7f, 0x5a, 0x79, 0x78, 0x7f, 0x4c, 0xdc, 0xb7, 0x41, 0xfc, 0x22, 0x25, 0xfe, 0xf1,
		0xf2, 0xca, 0xa5, 0xcd, 0xa7, 0x3d, 0xa2, 0xd6, 0xcb, 0xf7, 0x99, 0x6d, 0xb7, 0xa0, 0x94, 0x99,
		0x50, 0xb7, 0x9c, 0x53, 0x0b, 0x73, 0x3b, 0x15, 0xe9, 0x96, 0x73, 0x66, 0x81, 0xfe, 0x44, 0xa0,
		0xad, 0xe4, 0x8b, 0x67, 0x96, 0xc4, 0xb8, 0xe4, 0xd3, 0x42, 0xca, 0x99, 0xa2, 0xb4, 0x9c, 0x73,
		0x3b, 0xa4, 0x53, 0x75, 0xf1, 0x6d, 0x24, 0xfe, 0x5f, 0x5e, 0xb9, 0x2d, 0xe7, 0xc2, 0x02, 0xe5,
		0x31, 0x24, 0xb4, 0x9c, 0x93, 0x9a, 0x26, 0xb5, 0xd7, 0xa5, 0x44, 0xf9, 0x66, 0xcb, 0x3f, 0x11,
		0x95, 0x0e, 0xcf, 0xe9, 0x59, 0x2b, 0x21, 0x2e, 0x58, 0x37, 0xfb, 0x82, 0xa4, 0xf6, 0x9b, 0x23,
		0x53, 0x50, 0xfc, 0x86, 0x75, 0x93, 0xf4, 0xc7, 0xe8, 0xfc, 0xca, 0x5e, 0x14, 0x92, 0xff, 0x10,
		0x24, 0xe2, 0x52, 0x08, 0xc3, 0x62, 0xa7, 0x1f, 0x83, 0xf0, 0x6d, 0x8f, 0xa7, 0x2b, 0x17, 0xc3,
		0xd3, 0x38, 0xee, 0x47, 0xf6, 0x38, 0x43, 0x89, 0xf6, 0x5c, 0xbb, 0xfb, 0x39, 0xbe, 0xe3, 0x31,
		0xbf, 0xfb, 0xed, 0xc9, 0x6d, 0x39, 0xe1, 0xa0, 0xd7, 0xa3, 0x20, 0xf5, 0x2d, 0xe1, 0xb1, 0xd1,
		0xf1, 0xa0, 0x9d, 0xbd, 0x02, 0xc0, 0xa0, 0x68, 0xb4, 0xb4, 0xb6, 0xae, 0xad, 0xf4, 0xff, 0x81,
		0x45, 0x96, 0x9a, 0xb2, 0xd2, 0x1a, 0x0b, 0xd5, 0x66, 0x57, 0x7e, 0x8e, 0xe4, 0x5a, 0x4a, 0xce,
		0xa2, 0xfb, 0x07, 0x7f, 0x32, 0xb8, 0x17, 0x41, 0xcf, 0x02, 0xea, 0x5b, 0x3c, 0x52, 0x0b, 0x67,
		0x60, 0xd1, 0x0c, 0x2c, 0x98, 0x2c, 0x63, 0x34, 0xc5, 0xda, 0x82, 0x38, 0x2b, 0x98, 0xa1, 0x55,
		0x66, 0x47, 0x4e, 0x27, 0x56, 0x4b, 0xf8, 0xf2, 0x16, 0x2b, 0xa6, 0x58, 0x75, 0x6a, 0x49, 0xa6,
		0x74, 0xf9, 0x9b, 0x57, 0xbf, 0xcf, 0xe2, 0x6f, 0x2a, 0xde, 0x70, 0x56, 0x9b, 0x2b, 0xb8, 0x26,
		0xa7, 0xb1, 0xf2, 0x1a, 0x6a, 0xa4, 0x91, 0x0a, 0x1a, 0xa8, 0xa0, 0x71, 0x55, 0x93, 0x23, 0xc9,
		0x76, 0x3d, 0x76, 0x2f, 0x51, 0x92, 0x05, 0x4a, 0xb1, 0x58, 0x1a, 0xca, 0xbc, 0x2e, 0x7e, 0x32,
		0xf7, 0x62, 0xab, 0x5e, 0x48, 0xf9, 0x45, 0x8a, 0x4f, 0x35, 0x1d, 0x7b, 0x66, 0x5c, 0x37, 0x08,
		0x05, 0x8f, 0x3b, 0xac, 0xcd, 0xcb, 0x17, 0x63, 0x4c, 0x33, 0x4c, 0xa7, 0x6d, 0xe6, 0x9e, 0x78,
		0x71, 0x0d, 0xe9, 0xca, 0xa0, 0xce, 0xb2, 0xe0, 0x4c, 0x21, 0xc8, 0x72, 0x17, 0x24, 0x8b, 0xcc,
		0xd4, 0xaa, 0x60, 0x89, 0x74, 0xd0, 0x43, 0x3a, 0x78, 0x51, 0x0a, 0x42, 0x64, 0x4f, 0xa6, 0xc8,
		0xd7, 0xaa, 0x1a, 0xc3, 0xd3, 0x89, 0xad, 0x7e, 0xa3, 0x12, 0x0f, 0xaa, 0xde, 0x68, 0x79, 0x39,
		0xef, 0x29, 0x4b, 0x2a, 0x36, 0xc5, 0x64, 0xe2, 0x66, 0x32, 0x2c, 0x92, 0x65, 0x95, 0x32, 0xcb,
		0x94, 0x59, 0xa7, 0xc8, 0x42, 0x3d, 0x03, 0xbd, 0xaa, 0x7c, 0xf4, 0xe8, 0x10, 0x52, 0xc8, 0x83,
		0xee, 0x8f, 0x7f, 0x22, 0x89, 0x0b, 0xaf, 0x8a, 0x87, 0x97, 0xa6, 0xfd, 0x56, 0xbc, 0xa2, 0x5c,
		0x2d, 0x77, 0xe9, 0x60, 0xab, 0x4a, 0x10, 0x55, 0x45, 0x28, 0x54, 0x85, 0x43, 0x5b, 0x48, 0xb4,
		0x85, 0x45, 0x53, 0x68, 0x68, 0xfc, 0x18, 0xd9, 0x5a, 0xe4, 0x45, 0xe1, 0x90, 0x9f, 0xc5, 0x85,
		0xb2, 0x25, 0x3b, 0x93, 0x6a, 0xd7, 0x05, 0x28, 0xc7, 0xf5, 0x75, 0xe2, 0xf6, 0x3a, 0xa2, 0xa7,
		0x2b, 0x82, 0xc6, 0xa2, 0x68, 0x2c, 0x92, 0x86, 0xa2, 0x69, 0x67, 0xb9, 0xa9, 0x5a, 0x3e, 0xbf,
		0x78, 0x28, 0x53, 0x79, 0xf2, 0x09, 0x8e, 0x76, 0x6a, 0x26, 0xb0, 0x68, 0x27, 0xaa, 0x98, 0x24,
		0xa4, 0x98, 0x08, 0xb8, 0xa9, 0xa0, 0x93, 0x09, 0x3c, 0x99, 0xe0, 0x13, 0x29, 0xc0, 0x7a, 0x76,
		0xb1, 0xb4, 0x13, 0x3a, 0x72, 0x9e, 0xf7, 0x38, 0xeb, 0xc4, 0xbc, 0xa3, 0xc3, 0xf2, 0x89, 0xad,
		0xd6, 0x08, 0x6c, 0xb9, 0xd7, 0xe3, 0xe5, 0xc5, 0xcb, 0x97, 0xe3, 0x9d, 0xcb, 0x82, 0xae, 0xd9,
		0xda, 0x03, 0x53, 0xda, 0x92, 0x60, 0x82, 0xeb, 0x9b, 0x8e, 0x51, 0x77, 0x3d, 0x9b, 0xd1, 0x80,
		0xcd, 0x80, 0xcd, 0xb0, 0x67, 0x33, 0x74, 0xef, 0xa2, 0x31, 0x03, 0x55, 0x4a, 0x70, 0x35, 0x04,
		0x59, 0x63, 0xc5, 0xa1, 0x50, 0x20, 0x4a, 0x45, 0xa2, 0x52, 0x28, 0x72, 0xc5, 0x22, 0x57, 0x30,
		0x62, 0x45, 0xd3, 0x53, 0x38, 0x4d, 0xc5, 0x33, 0x07, 0x6d, 0x1b, 0x3a, 0xe4, 0x10, 0x1d, 0xc7,
		0x22, 0x3b, 0x7e, 0xb5, 0x05, 0xb5, 0x44, 0x6e, 0x6b, 0x7c, 0xf9, 0x70, 0x2f, 0x08, 0x7f, 0x7a,
		0x3d, 0xf6, 0xc4, 0x63, 0x3a, 0x53, 0xbd, 0x80, 0x26, 0x0c, 0x36, 0x0c, 0x36, 0x0c, 0xb6, 0xb2,
		0xcc, 0xd0, 0x1c, 0xa7, 0xad, 0x97, 0xbd, 0xb6, 0x79, 0x3c, 0xf6, 0x16, 0xb9, 0x26, 0xd2, 0x11,
		0xb9, 0x54, 0xa3, 0xa2, 0x07, 0x1e, 0x3f, 0x1d, 0x4f, 0x23, 0x69, 0xd3, 0x5f, 0x8f, 0x8b, 0x5b,
		0xfd, 0xc5, 0x3f, 0xb7, 0x30, 0xf5, 0x44, 0xc3, 0xf5, 0x41, 0xda, 0xc9, 0x96, 0xa6, 0x9d, 0x18,
		0x48, 0xb6, 0x7e, 0x16, 0xca, 0xfb, 0x09, 0xfd, 0xbf, 0xdf, 0xdf, 0x3f, 0x34, 0x3f, 0x4d, 0xe8,
		0xed, 0x70, 0x2a, 0x8a, 0xd2, 0x34, 0x6b, 0x67, 0xa6, 0x1c, 0x2d, 0x8d, 0x62, 0xfa, 0x9a, 0x51,
		0x4c, 0x1f, 0x51, 0x4c, 0x53, 0x5f, 0x70, 0x77, 0xa3, 0x98, 0xbe, 0x59, 0x14, 0xd3, 0x47, 0x14,
		0x13, 0x51, 0x4c, 0x02, 0x90, 0xd4, 0x89, 0x62, 0xfa, 0x24, 0x51, 0x4c, 0x1f, 0x51, 0xcc, 0xb5,
		0xac, 0xc7, 0x11, 0x91, 0xd0, 0x5a, 0x1f, 0xed, 0x54, 0x14, 0xd3, 0x47, 0x14, 0x13, 0x51, 0x4c,
		0xd8, 0x8c, 0x3a, 0x47, 0x31, 0x7d, 0xd2, 0x28, 0xa6, 0x8f, 0x4d, 0x71, 0x6c, 0x8a, 0x63, 0x53,
		0x7c, 0xa3, 0x3a, 0x54, 0xbf, 0x5d, 0x71, 0x94, 0x8a, 0xde, 0xbe, 0x52, 0xd1, 0x88, 0xeb, 0x02,
		0xc2, 0x00, 0x61, 0x80, 0x30, 0x75, 0x99, 0x41, 0x5c, 0xb7, 0xa6, 0x96, 0x76, 0x2f, 0xe2, 0xba,
		0x7e, 0x31, 0xfa, 0xe5, 0x6f, 0x79, 0x5c, 0xd7, 0x47, 0x5c, 0x57, 0xb1, 0xeb, 0xce, 0xc6, 0x75,
		0x2b, 0x25, 0x9b, 0x28, 0xae, 0xeb, 0x23, 0xae, 0x3b, 0x37, 0xcd, 0x36, 0xe2, 0xba, 0xe3, 0xa9,
		0x97, 0x8c, 0xe6, 0x2e, 0x29, 0x43, 0xa0, 0xe8, 0x6f, 0x22, 0x86, 0x5b, 0xef, 0x18, 0xae, 0xb4,
		0xff, 0xa5, 0xb1, 0xcf, 0xaf, 0xb2, 0xaf, 0x5f, 0xde, 0xc7, 0xcf, 0x64, 0xd0, 0x82, 0x26, 0xc8,
		0xed, 0xc7, 0x2b, 0xed, 0xbf, 0x23, 0x9f, 0x61, 0x27, 0x74, 0x41, 0x3a, 0x9f, 0x41, 0xca, 0x98,
		0xea, 0x18, 0x55, 0xcd, 0xc5, 0x3c, 0xb2, 0x17, 0xac, 0x2d, 0xb6, 0x6b, 0x95, 0xbd, 0xa0, 0xbc,
		0x58, 0xd6, 0xbf, 0x9f, 0x41, 0xf1, 0xfe, 0x85, 0x9d, 0xf4, 0xca, 0x24, 0x56, 0x6e, 0x28, 0xff,
		0xb4, 0x75, 0xe5, 0x9f, 0x96, 0x33, 0x5d, 0xbe, 0x1a, 0x54, 0xbe, 0x88, 0xa9, 0x53, 0x49, 0xa8,
		0x45, 0x2f, 0x27, 0x53, 0x1c, 0xea, 0x3e, 0x8a, 0xc5, 0x92, 0xba, 0x50, 0xa3, 0xaf, 0xd7, 0x54,
		0x12, 0x2a, 0x1d, 0xac, 0x9e, 0x25, 0xa1, 0xb2, 0x27, 0xa3, 0x2a, 0x09, 0x95, 0x11, 0x5b, 0x59,
		0x0d, 0xaa, 0x62, 0x32, 0x9c, 0x4d, 0x14, 0x82, 0x5a, 0xf2, 0x2c, 0x4e, 0xbd, 0x0b, 0x41, 0x2d,
		0x66, 0x9c, 0x9e, 0xa9, 0x5e, 0x59, 0x08, 0x6a, 0x77, 0x97, 0xda, 0x2b, 0x04, 0x60, 0x8b, 0x97,
		0x17, 0xcb, 0x05, 0x04, 0x4b, 0x6d, 0x2c, 0xb5, 0xa1, 0x0b, 0x1b, 0x59, 0x6a, 0xb7, 0xa3, 0x41,
		0xea, 0xc8, 0x24, 0xea, 0xcb, 0xed, 0xbc, 0xe7, 0x8e, 0x1c, 0x18, 0x90, 0x14, 0xb8, 0x1d, 0x5c,
		0x72, 0xcb, 0x09, 0xa4, 0x9d, 0x25, 0xb7, 0xfa, 0x81, 0x81, 0xd0, 0xeb, 0xc4, 0xac, 0xcf, 0x4d,
		0x4e, 0x0b, 0xe4, 0x24, 0xf6, 0xe4, 0xa8, 0x80, 0xa2, 0x68, 0x9b, 0x8a, 0x38, 0x99, 0xa8, 0x93,
		0x89, 0x3c, 0x91, 0xe8, 0xab, 0xa9, 0x80, 0xa2, 0x2a, 0xe8, 0xef, 0x42, 0x55, 0x99, 0x66, 0xad,
		0xdb, 0xc2, 0x26, 0x42, 0xae, 0x91, 0x9f, 0xe1, 0x7e, 0x61, 0x61, 0x97, 0x6b, 0x67, 0x65, 0x98,
		0x5d, 0x14, 0x62, 0x9e, 0x88, 0x34, 0xba, 0x9e, 0xc5, 0xf8, 0xfe, 0x4c, 0xf7, 0x5d, 0xcc, 0xda,
		0x22, 0x88, 0xc2, 0x37, 0x41, 0x37, 0x30, 0xbd, 0xb8, 0x64, 0xc4, 0x56, 0xde, 0x65, 0x22, 0x78,
		0xe0, 0x46, 0xf7, 0x81, 0x38, 0x66, 0x77, 0xfc, 0xb8, 0x1f, 0xd9, 0x23, 0xdd, 0x14, 0xd3, 0x5e,
		0xc0, 0x52, 0xf7, 0x59, 0x5f, 0x53, 0x22, 0xd0, 0x6d, 0x0d, 0x0e, 0xe3, 0x04, 0xa1, 0x17, 0xb5,
		0x05, 0x17, 0x66, 0xe8, 0x3c, 0x26, 0x01, 0x74, 0x06, 0x3a, 0x03, 0x9d, 0x81, 0xce, 0x40, 0x67,
		0xa0, 0x33, 0xd0, 0x99, 0x00, 0x9d, 0xa3, 0x81, 0x30, 0x5e, 0x3c, 0xcf, 0xd0, 0x00, 0x3e, 0x03,
		0x9f, 0x81, 0xcf, 0xc0, 0x67, 0xe0, 0x33, 0xf0, 0x19, 0xf8, 0x4c, 0x84, 0xcf, 0xa6, 0xcb, 0xe7,
		0x19, 0x1a, 0xc0, 0x67, 0xe0, 0x33, 0xf0, 0x19, 0xf8, 0x0c, 0x7c, 0x06, 0x3e, 0x03, 0x9f, 0x8d,
		0x5a, 0xd6, 0xe3, 0x30, 0x61, 0x6a, 0xcf, 0x8f, 0xb3, 0x5c, 0xd1, 0xec, 0xe7, 0x38, 0xbb, 0x48,
		0x31, 0x11, 0xc3, 0x29, 0xa7, 0xda, 0x5e, 0x47, 0xb1, 0xf8, 0xfb, 0x6a, 0x42, 0x86, 0x2a, 0x21,
		0x5d, 0x22, 0x79, 0x27, 0x08, 0xbd, 0x58, 0xa5, 0x7a, 0xd7, 0x6c, 0x90, 0x20, 0x96, 0xaf, 0xdb,
		0x55, 0xfb, 0xe3, 0x1e, 0xc8, 0x3d, 0xd9, 0x84, 0xb2, 0xea, 0x1f, 0xf7, 0x08, 0x38, 0xe7, 0x9d,
		0x5e, 0xc4, 0xc4, 0xd9, 0xa9, 0xc6, 0x99, 0x8f, 0xd7, 0x0a, 0x5d, 0x3e, 0xf0, 0xb0, 0x9b, 0x19,
		0x05, 0x35, 0xaf, 0x43, 0xc3, 0xbd, 0x32, 0xf1, 0x32, 0x72, 0xe8, 0x6b, 0x6a, 0x7a, 0xae, 0x54,
		0xf8, 0x66, 0x8e, 0x6b, 0x3a, 0x85, 0x6b, 0x4c, 0xbc, 0x87, 0x5d, 0x9a, 0x3a, 0x4b, 0x10, 0x7d,
		0xbb, 0x46, 0x44, 0xea, 0x05, 0xe1, 0x4f, 0x75, 0x38, 0xca, 0x7a, 0x01, 0x8b, 0x80, 0x45, 0x1b,
		0xc0, 0x22, 0x1e, 0x0e, 0xfa, 0xa9, 0x7f, 0x98, 0xfa, 0x9c, 0x1a, 0xe7, 0x0f, 0x15, 0xcc, 0x8e,
		0xfb, 0x36, 0x1c, 0xf4, 0xd5, 0x19, 0x7d, 0x13, 0x7d, 0x1d, 0x9d, 0x8e, 0xd4, 0x5a, 0xf5, 0x9f,
		0xa4, 0xef, 0xf8, 0xed, 0x5a, 0x67, 0xad, 0xdf, 0x48, 0xbb, 0xbe, 0xf9, 0xfc, 0x9f, 0x4f, 0xae,
		0xdd, 0x1d, 0x8d, 0xe8, 0x7d, 0x28, 0xf4, 0x5e, 0x2e, 0x7b, 0x38, 0xe5, 0x3a, 0xb2, 0x59, 0xd7,
		0x6f, 0xd7, 0xa9, 0x4d, 0xd8, 0xec, 0xa2, 0x88, 0xc4, 0xe2, 0xe2, 0xb0, 0x37, 0x2c, 0xee, 0x76,
		0x59, 0xdc, 0x1a, 0x1c, 0xf6, 0x96, 0xd0, 0xab, 0x68, 0x20, 0x34, 0x17, 0xd7, 0x79, 0x4f, 0xe8,
		0x17, 0xf4, 0x0b, 0xab, 0x6b, 0xac, 0xae, 0xb1, 0xba, 0xc6, 0xea, 0x7a, 0x2b, 0x0b, 0x90, 0x2c,
		0xdc, 0x30, 0x47, 0xc5, 0x91, 0x45, 0x9d, 0xb7, 0xb8, 0xe2, 0xc8, 0x1c, 0x97, 0xe5, 0x4b, 0x8c,
		0x5c, 0x57, 0xc2, 0xe3, 0x66, 0xaa, 0x8b, 0x4c, 0x5f, 0xa4, 0xb2, 0xa6, 0xc8, 0xc1, 0xcc, 0xe8,
		0x55, 0xa3, 0xba, 0x41, 0x72, 0x15, 0xf5, 0xef, 0x63, 0x9e, 0x24, 0xfc, 0xee, 0x6b, 0x36, 0x72,
		0xc9, 0x9d, 0x70, 0x83, 0xe4, 0x1d, 0xfb, 0xc9, 0xbf, 0x44, 0x51, 0xd9, 0xd5, 0x98, 0x7f, 0x5a,
		0x77, 0xf6, 0xab, 0xc2, 0x04, 0xbe, 0xe1, 0x0f, 0xc1, 0xa4, 0x40, 0xcb, 0xf0, 0x60, 0xf8, 0x3f,
		0x00, 0x00, 0x00, 0xff, 0xff, 0x01, 0x00, 0x00, 0xff, 0xff, 0x79, 0xdc, 0x99, 0x2c, 0x5a, 0x97,
		0x01, 0x00,
	}
)

// ΛEnumTypes is a map, keyed by a YANG schema path, of the enumerated types that
// correspond with the leaf. The type is represented as a reflect.Type. The naming
// of the map ensures that there are no clashes with valid YANG identifiers.
func initΛEnumTypes() {
	ΛEnumTypes = map[string][]reflect.Type{
		"/flows/flow/tagged-metrics/tagged-metric/state/tags/tag-value/value-type": {
			reflect.TypeOf((E_Tags_ValueType)(0)),
		},
		"/ports/port/state/link": {
			reflect.TypeOf((E_Port_Link)(0)),
		},
	}
}
